<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High Utilization LP Dashboard</title>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --bg-color-lighter: #111111;
            --surface-color: #1a1a1a;
            --surface-color-alt: #141414;
            --primary-text-color: #e0e0e0;
            --secondary-text-color: #888888;
            --border-color: #2a2a2a;
            --accent-color: #666666;
            --hover-bg-color: #222222;
            --success-color: #4ade80;
            --warning-color: #fbbf24;
            --error-color: #f87171;
            --btc-color: #f7931a;
            --eth-color: #87CEEB;
            --usdc-color: #4A90E2;
            --usdt-color: #5CB85C;
            --dai-color: #D4A76A;
            --sol-color: #9945FF;
            --sui-color: #6fbcf0;
            --apr-low: #1a5f2a;
            --apr-moderate: #2d8a3e;
            --apr-good: #48bb5c;
            --apr-excellent: #4ade80;
            --util-low: #4a3a6b;
            --util-moderate: #7c5dac;
            --util-high: #a78bfa;
            --util-excellent: #c4b5fd;
            --section-bg: #0f0f0f;
            --section-border: #2a2a2a;
            --section-header-bg: #151515;
            --section-th-bg: #121212;
            --link-color: #999999;
            --link-color-hover: #cccccc;
            --liquidity-bar-color: hsl(270, 50%, 35%);
            --geckoterminal-color: #7c3aed;
            --dexscreener-color: #14F195;
            
            /* New Section Title Color */
            --section-title-color: #9E6CFF;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-text-color);
            line-height: 1.5;
            min-height: 100vh;
        }

        header {
            padding: 1.25rem 2rem;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-color-lighter);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 1rem;
            max-width: 1920px;
            margin: 0 auto;
        }

        .header-left h1 {
            font-size: 1.6rem;
            font-weight: 600;
            color: var(--primary-text-color);
            margin-bottom: 0.4rem;
        }

        .header-left p {
            color: var(--secondary-text-color);
            font-size: 0.9rem;
        }

        .header-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.5rem;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-status {
            font-size: 0.8rem;
            color: var(--secondary-text-color);
            text-align: right;
        }

        .header-status .pool-count {
            color: var(--success-color);
            font-weight: 600;
        }

        .header-status .network-count {
            color: var(--util-high);
            font-weight: 500;
        }

        .header-status .loading-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--warning-color);
        }

        .header-status .error-indicator {
            color: var(--error-color);
        }

        main {
            padding: 1.25rem;
            max-width: 1920px;
            margin: 0 auto;
        }

        footer {
            padding: 0.75rem 2rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.8rem;
            color: var(--secondary-text-color);
        }

        .data-sources {
            margin-top: 0.5rem;
            font-size: 0.75rem;
        }

        .source-gecko { color: var(--geckoterminal-color); }
        .source-dexscreener { color: var(--dexscreener-color); }

        .btn {
            background-color: #333333;
            color: #fff;
            border: 1px solid #444444;
            padding: 0.5rem 1rem;
            border-radius: 3px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .btn:hover {
            background-color: #444444;
            transform: translateY(-1px);
        }

        .btn:disabled {
            background-color: #222222;
            color: var(--secondary-text-color);
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary {
            background-color: var(--util-moderate);
            border-color: var(--util-high);
        }

        .btn-primary:hover {
            background-color: var(--util-high);
        }

        .btn-sm {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        #progress-container {
            width: 100%;
            height: 4px;
            background-color: var(--border-color);
            border-radius: 2px;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        #progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--geckoterminal-color), var(--util-excellent));
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--primary-text-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .spinner-sm {
            width: 12px;
            height: 12px;
            border-width: 1.5px;
        }

        .hidden { display: none !important; }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #dashboard-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.25rem;
            min-height: 500px;
        }

        #stablecoin-section-wrapper {
            margin-top: 1.25rem;
        }

        .pair-section {
            background-color: var(--section-bg);
            border: 1px solid var(--section-border);
            border-radius: 3px;
            display: flex;
            flex-direction: column;
            min-height: 320px;
            max-height: 450px;
            position: relative;
        }

        .pair-section.full-width {
            max-height: 380px;
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background-color: var(--section-header-bg);
            border-bottom: 1px solid var(--section-border);
            flex-shrink: 0;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.05rem;
            font-weight: 600;
            color: var(--section-title-color); /* Updated Color */
        }

        /* Override token colors inside section titles to enforce the purple theme */
        .section-title span {
            color: inherit !important;
        }

        .pool-count {
            font-size: 0.85rem;
            font-weight: 400;
            opacity: 0.7;
        }

        .section-controls {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            flex-wrap: wrap;
        }

        .timeframe-toggle {
            display: flex;
            align-items: center;
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 2px;
            gap: 2px;
        }

        .tf-btn {
            background-color: transparent;
            color: var(--secondary-text-color);
            border: none;
            padding: 0.3rem 0.55rem;
            border-radius: 2px;
            font-size: 0.72rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
        }

        .tf-btn:hover {
            background-color: var(--hover-bg-color);
            color: var(--primary-text-color);
        }

        .tf-btn.active {
            background-color: var(--util-moderate);
            color: #fff;
        }
        
        .tf-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .network-selector {
            position: relative;
        }

        .network-btn {
            background-color: var(--surface-color);
            color: var(--secondary-text-color);
            border: 1px solid var(--border-color);
            padding: 0.35rem 0.65rem;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .network-btn:hover {
            background-color: var(--hover-bg-color);
            color: var(--primary-text-color);
            border-color: #444;
        }

        .network-btn.open {
            border-color: var(--util-moderate);
        }

        .network-badge {
            background-color: var(--util-moderate);
            color: #fff;
            font-size: 0.65rem;
            padding: 0.1rem 0.35rem;
            border-radius: 2px;
            font-weight: 600;
        }

        .network-arrow {
            font-size: 0.55rem;
            transition: transform 0.2s ease;
        }

        .network-btn.open .network-arrow {
            transform: rotate(180deg);
        }

        .network-dropdown {
            position: fixed;
            width: 320px;
            max-width: calc(100vw - 20px);
            max-height: 600px;
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            z-index: 9999;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
        }

        .network-dropdown.open {
            display: flex;
        }

        .dropdown-header {
            padding: 0.6rem 0.75rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.7rem;
            color: var(--secondary-text-color);
            text-transform: uppercase;
            letter-spacing: 0.03em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .dropdown-header button {
            background: none;
            border: none;
            color: var(--util-high);
            font-size: 0.7rem;
            cursor: pointer;
            padding: 0;
        }

        .dropdown-header button:hover {
            text-decoration: underline;
        }

        .dropdown-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.4rem 0;
        }

        .network-group-label {
            font-size: 0.65rem;
            color: var(--secondary-text-color);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.5rem 0.75rem 0.25rem;
            opacity: 0.7;
        }

        .network-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.75rem;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        .network-item:hover {
            background-color: var(--hover-bg-color);
        }

        .network-item.selected {
            background-color: rgba(167, 139, 250, 0.1);
        }

        .network-item.not-loaded {
            opacity: 0.5;
        }

        .network-item.not-loaded:hover {
            background-color: rgba(251, 191, 36, 0.1);
            opacity: 0.7;
        }

        .network-item.not-loaded.selected {
            background-color: rgba(251, 191, 36, 0.15);
            opacity: 0.8;
        }

        .network-checkbox {
            width: 14px;
            height: 14px;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            color: #fff;
            background-color: var(--bg-color);
            flex-shrink: 0;
        }

        .network-item.selected .network-checkbox {
            background-color: var(--util-moderate);
            border-color: var(--util-high);
        }

        .network-item.not-loaded.selected .network-checkbox {
            background-color: var(--warning-color);
            border-color: var(--warning-color);
        }

        .network-name {
            font-size: 0.8rem;
            color: var(--primary-text-color);
            flex: 1;
        }

        .fast-tag {
            font-size: 0.6rem;
            color: var(--sol-color);
            background-color: rgba(153, 69, 255, 0.15);
            padding: 0.1rem 0.3rem;
            border-radius: 2px;
        }

        .dropdown-footer {
            padding: 0.6rem 0.75rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            gap: 0.5rem;
        }

        .dropdown-footer-info {
            font-size: 0.7rem;
            color: var(--secondary-text-color);
        }

        .dropdown-footer-info .to-load {
            color: var(--warning-color);
            font-weight: 600;
        }

        .dropdown-footer-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .dropdown-footer .btn {
            padding: 0.35rem 0.75rem;
            font-size: 0.75rem;
        }

        .section-overlay {
            position: absolute;
            inset: 0;
            background-color: rgba(10, 10, 10, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
        }

        .section-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .section-overlay .spinner {
            width: 28px;
            height: 28px;
            border-width: 3px;
            border-top-color: var(--util-high);
            margin-bottom: 0.75rem;
        }

        .section-overlay-text {
            font-size: 0.85rem;
            color: var(--secondary-text-color);
            text-align: center;
            padding: 0 1rem;
        }

        .section-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .table-container {
            flex: 1;
            overflow: auto;
            min-height: 0;
        }

        .pool-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            table-layout: fixed;
        }

        .pool-table th,
        .pool-table td {
            padding: 0.55rem 0.7rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            white-space: nowrap;
            vertical-align: middle;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .pool-table .col-chain { width: 80px; }
        .pool-table .col-protocol { width: 90px; }
        .pool-table .col-pool { width: 200px; min-width: 180px; }
        .pool-table .col-fee { width: 65px; }
        .pool-table .col-liquidity { width: 100px; }
        .pool-table .col-volume { width: 110px; }
        .pool-table .col-util { width: 80px; }
        .pool-table .col-apr { width: 90px; }

        .pool-table .col-liquidity,
        .pool-table .col-volume,
        .pool-table .col-util,
        .pool-table .col-apr,
        .pool-table td:nth-child(5),
        .pool-table td:nth-child(6),
        .pool-table td:nth-child(7),
        .pool-table td:nth-child(8) {
            text-align: right;
        }

        .pool-table th {
            background-color: var(--section-th-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
            font-size: 0.73rem;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            color: var(--secondary-text-color);
        }

        .pool-table th:hover {
            color: var(--primary-text-color);
        }

        .pool-table th[data-sort]::after {
            content: ' ⇅';
            opacity: 0.4;
            font-size: 0.65em;
        }

        .pool-table th.sort-asc::after {
            content: ' ↑';
            opacity: 1;
        }

        .pool-table th.sort-desc::after {
            content: ' ↓';
            opacity: 1;
        }

        .pool-table tbody tr {
            transition: background-color 0.15s ease;
        }

        .pool-table tbody tr:hover {
            background-color: var(--hover-bg-color);
        }

        .pool-table tbody tr:last-child td {
            border-bottom: none;
        }

        .pool-link,
        .explorer-link {
            color: var(--link-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.15s ease;
        }

        .pool-link:hover,
        .explorer-link:hover {
            color: var(--link-color-hover);
            text-decoration: underline;
        }

        .pool-cell {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            min-width: 180px;
        }

        .pool-cell .pool-link {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .pool-cell .explorer-link {
            flex-shrink: 0;
            width: 18px;
            text-align: center;
            font-size: 0.75rem;
            opacity: 0.5;
        }

        .pool-cell .explorer-link:hover {
            opacity: 1;
        }

        .token-btc { color: var(--btc-color); font-weight: 600; }
        .token-eth { color: var(--eth-color); font-weight: 600; }
        .token-usdc { color: var(--usdc-color); font-weight: 600; }
        .token-usdt { color: var(--usdt-color); font-weight: 600; }
        .token-dai { color: var(--dai-color); font-weight: 600; }
        .token-sol { color: var(--sol-color); font-weight: 600; }
        .token-sui { color: var(--sui-color); font-weight: 600; }
        .token-stable { color: var(--primary-text-color); font-weight: 500; }
        .token-prefix { font-weight: 400; }

        .protocol-badge {
            display: inline-block;
            padding: 0.1rem 0.35rem;
            border-radius: 2px;
            font-size: 0.7rem;
            font-weight: 500;
            /* Base style, color set via JS/Inline */
            background-color: rgba(255, 255, 255, 0.08); 
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .fee-badge {
            display: inline-block;
            padding: 0.12rem 0.35rem;
            border-radius: 2px;
            font-size: 0.75rem;
            font-weight: 600;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--secondary-text-color);
        }

        .fee-badge.fee-low { background-color: rgba(74, 222, 128, 0.2); color: var(--success-color); }
        .fee-badge.fee-medium { background-color: rgba(251, 191, 36, 0.2); color: var(--warning-color); }
        .fee-badge.fee-high { background-color: rgba(248, 113, 113, 0.2); color: var(--error-color); }

        .liquidity-cell {
            position: relative;
            font-weight: 500;
        }

        .liquidity-bar {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            opacity: 0.4;
            border-radius: 1px;
            z-index: 0;
            background: linear-gradient(90deg, hsl(270, 50%, 25%), hsl(270, 50%, 40%));
        }

        .liquidity-value {
            position: relative;
            z-index: 1;
        }

        .apr-value { font-weight: 600; }
        .apr-excellent { color: var(--apr-excellent); }
        .apr-good { color: var(--apr-good); }
        .apr-moderate { color: var(--apr-moderate); }
        .apr-low { color: var(--apr-low); }

        .utilization-value { font-weight: 600; }
        .utilization-excellent { color: var(--util-excellent); }
        .utilization-high { color: var(--util-high); }
        .utilization-moderate { color: var(--util-moderate); }
        .utilization-low { color: var(--util-low); }

        .no-data {
            text-align: center;
            padding: 2.5rem 1rem;
            color: var(--secondary-text-color);
            font-size: 0.9rem;
        }

        .tf-indicator {
            font-size: 0.65rem;
            opacity: 0.6;
            margin-left: 0.2rem;
            display: inline-block;
            min-width: 28px;
        }

        .volume-cell, .apr-cell { white-space: nowrap; }

        .table-container::-webkit-scrollbar { width: 8px; height: 8px; }
        .table-container::-webkit-scrollbar-track { background: var(--bg-color); }
        .table-container::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }
        .table-container::-webkit-scrollbar-thumb:hover { background: var(--secondary-text-color); }

        #debug-section {
            margin-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            padding-top: 1rem;
        }

        .debug-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .debug-toggle {
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            color: var(--secondary-text-color);
            padding: 0.3rem 0.6rem;
            border-radius: 2px;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .debug-toggle:hover {
            background-color: var(--hover-bg-color);
            color: var(--primary-text-color);
        }

        #debug-log {
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 1rem;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 0.72rem;
            max-height: 280px;
            overflow-y: auto;
            line-height: 1.5;
        }

        .log-error { color: var(--error-color); }
        .log-warn { color: var(--warning-color); }
        .log-success { color: var(--success-color); }
        .log-info { color: var(--secondary-text-color); }
        .log-gecko { color: var(--geckoterminal-color); }
        .log-dexscreener { color: var(--dexscreener-color); }

        @media (max-width: 1200px) {
            #dashboard-grid { grid-template-columns: 1fr; }
        }

        @media (max-width: 768px) {
            header { padding: 1rem; }
            .header-content { flex-direction: column; align-items: flex-start; }
            .header-right { align-items: flex-start; width: 100%; }
            .header-left h1 { font-size: 1.3rem; }
            main { padding: 0.75rem; }
            .section-header { flex-direction: column; align-items: flex-start; }
            .section-controls { width: 100%; justify-content: space-between; }
            .pair-section { min-height: 280px; max-height: 400px; }
            .pool-table th, .pool-table td { padding: 0.45rem 0.5rem; font-size: 0.78rem; }
            .pool-table .col-pool { min-width: 150px; }
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="header-left">
                <h1>High Utilization LP Dashboard</h1>
                <p>Find heavily utilized LPs. Ranks pools by Utilization % (Volume ÷ Liquidity × 100). APR estimated from volume × fee. Powered by GeckoTerminal.</p>
            </div>
            <div class="header-right">
                <div class="header-controls">
                    <div class="header-status" id="header-status">
                        <span class="loading-indicator">
                            <span class="spinner spinner-sm"></span>
                            Initializing...
                        </span>
                    </div>
                    <button id="refresh-btn" class="btn btn-sm">Refresh Data</button>
                </div>
                <div id="last-updated" style="font-size: 0.75rem; color: var(--secondary-text-color);"></div>
            </div>
        </div>
    </header>

    <main>
        <div id="progress-container" class="hidden">
            <div id="progress-bar"></div>
        </div>
        <div id="dashboard-grid"></div>
        <div id="stablecoin-section-wrapper"></div>
        <div id="debug-section" class="hidden">
            <div class="debug-header">
                <span style="font-size: 0.75rem; color: var(--secondary-text-color);">Debug Log</span>
                <button id="clear-debug" class="debug-toggle">Clear</button>
            </div>
            <div id="debug-log"></div>
        </div>
    </main>

    <footer>
        <p>
            Always DYOR. Historical data (7d/30d/1y) relies on GeckoTerminal API limits.
            <button id="debug-toggle" class="debug-toggle" style="margin-left: 1rem;">Toggle Debug</button>
        </p>
        <div class="data-sources">
            <span class="source-gecko">● GeckoTerminal (Unified Data Source)</span>
        </div>
    </footer>

    <script>
    (function() {
        'use strict';

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            // API Endpoints
            APIS: {
                GECKOTERMINAL: 'https://api.geckoterminal.com/api/v2',
            },

            // Rate limits
            RATE_LIMITS: {
                GECKOTERMINAL: 2200,
                DEFAULT: 2000
            },

            MAX_RETRIES: 3,
            RETRY_DELAY_MS: 2000,
            TIMEOUT_MS: 15000,
            MIN_LIQUIDITY: 50000,
            MIN_VOLUME_24H: 1000,
            POOLS_PER_PAGE: 20,
            MAX_PAGES_PER_NETWORK: 5,
            
            INITIAL_NETWORKS: ['solana', 'sui', 'eth', 'arbitrum', 'base'],

            // All internal networks supported (GeckoTerminal IDs)
            ALL_SUPPORTED_NETWORKS: [
                'eth', 'arbitrum', 'optimism', 'base', 'polygon_pos', 'zksync', 
                'linea', 'bsc', 'avax', 'fantom', 'gnosis', 'mode', 'mantle', 
                'manta', 'scroll', 'blast', 'celo', 'solana', 'sui'
            ],

            NETWORK_GROUPS: {
                'Non-EVM (Fast)': [
                    { id: 'solana', name: 'Solana', initial: true, fast: true },
                    { id: 'sui', name: 'Sui', initial: true, fast: true }
                ],
                'L1 Networks': [
                    { id: 'eth', name: 'Ethereum', initial: true },
                    { id: 'bsc', name: 'BSC' },
                    { id: 'avax', name: 'Avalanche' },
                    { id: 'fantom', name: 'Fantom' },
                    { id: 'gnosis', name: 'Gnosis' }
                ],
                'Ethereum L2s': [
                    { id: 'arbitrum', name: 'Arbitrum', initial: true },
                    { id: 'base', name: 'Base', initial: true },
                    { id: 'optimism', name: 'Optimism' },
                    { id: 'zksync', name: 'zkSync' },
                    { id: 'linea', name: 'Linea' },
                    { id: 'mode', name: 'Mode' },
                    { id: 'manta', name: 'Manta' },
                    { id: 'scroll', name: 'Scroll' },
                    { id: 'blast', name: 'Blast' },
                    { id: 'mantle', name: 'Mantle' }
                ],
                'Other': [
                    { id: 'polygon_pos', name: 'Polygon' },
                    { id: 'celo', name: 'Celo' }
                ]
            },

            NETWORK_NAMES: {
                eth: 'Ethereum', arbitrum: 'Arbitrum', optimism: 'Optimism', base: 'Base',
                polygon_pos: 'Polygon', zksync: 'zkSync', linea: 'Linea', bsc: 'BSC',
                avax: 'Avalanche', fantom: 'Fantom', gnosis: 'Gnosis', mode: 'Mode',
                manta: 'Manta', scroll: 'Scroll', blast: 'Blast', mantle: 'Mantle',
                celo: 'Celo', solana: 'Solana', sui: 'Sui'
            },

            EXPLORERS: {
                eth: 'https://etherscan.io/address/',
                arbitrum: 'https://arbiscan.io/address/',
                optimism: 'https://optimistic.etherscan.io/address/',
                base: 'https://basescan.org/address/',
                polygon_pos: 'https://polygonscan.com/address/',
                zksync: 'https://explorer.zksync.io/address/',
                linea: 'https://lineascan.build/address/',
                bsc: 'https://bscscan.com/address/',
                avax: 'https://snowtrace.io/address/',
                fantom: 'https://ftmscan.com/address/',
                gnosis: 'https://gnosisscan.io/address/',
                mode: 'https://explorer.mode.network/address/',
                manta: 'https://pacific-explorer.manta.network/address/',
                scroll: 'https://scrollscan.com/address/',
                blast: 'https://blastscan.io/address/',
                solana: 'https://solscan.io/account/',
                sui: 'https://suiscan.xyz/mainnet/object/'
            },

            SEARCHES: {
                'btc-stable': ['WBTC USDC', 'WBTC USDT', 'cbBTC USDC', 'tBTC USDC', 'WBTC DAI', 'BTC USDC', 'BTC USDT'],
                'eth-stable': ['WETH USDC', 'WETH USDT', 'ETH USDC', 'ETH USDT', 'WETH DAI', 'ETH DAI', 'stETH USDC', 'rETH USDC', 'cbETH USDC'],
                'btc-eth': ['WBTC WETH', 'WBTC ETH', 'cbBTC WETH', 'BTC ETH', 'WBTC rETH', 'WBTC stETH'],
                'wrapped': ['wstETH WETH', 'wstETH ETH', 'rETH WETH', 'rETH ETH', 'cbETH WETH', 'cbETH ETH', 'stETH ETH', 'wstETH rETH'],
                'stable-stable': ['USDC USDT', 'USDC DAI', 'USDT DAI', 'GHO USDC', 'FRAX USDC', 'LUSD USDC', 'crvUSD USDC']
            },

            TIMEFRAMES: {
                '24h': { days: 1, label: '24h' },
                '7d': { days: 7, label: '7d' },
                '30d': { days: 30, label: '30d' },
                '1y': { days: 365, label: '1y' }
            },

            SECTIONS: [
                { id: 'btc-stable', title: '<span class="token-btc">BTC</span> / Stablecoin', grid: true },
                { id: 'eth-stable', title: 'ETH / Stablecoin', grid: true },
                { id: 'btc-eth', title: '<span class="token-btc">BTC</span> / <span class="token-eth">ETH</span>', grid: true },
                { id: 'wrapped', title: 'Wrapped & LST (ETH)', grid: true },
                { id: 'stable-stable', title: 'Stablecoin Pairs', grid: false }
            ],

            ASSETS: {
                BTC: ['btc', 'wbtc', 'cbbtc', 'tbtc', 'renbtc', 'sbtc', 'hbtc', 'wbtce', 'btcb', 'obtc', 'pbtc', 'ibtc', 'fbtc', 'lbtc', 'kbtc', 'ebtc', 'solvbtc', 'unibtc', 'pumpbtc', 'dlcbtc', 'stbtc', 'mbtc', 'xbtc', 'abtc', 'nbtc', 'dbtc', 'zbtc', 'ubtc', 'hemibtc', 'vbtc', 'yybtc', 'bbtc', 'gbtc', 'qbtc'],
                ETH: ['eth', 'weth', 'steth', 'wsteth', 'reth', 'cbeth', 'wethe', 'ethb', 'seth', 'meth', 'oeth', 'frxeth', 'sfrxeth', 'sweth', 'ankreth', 'eeth', 'weeth', 'ezeth', 'rseth', 'pxeth', 'unieth', 'ethx', 'insteth', 'neth', 'oseth', 'mpeth', 'ineth', 'wbeth', 'rsweth', 'saeth', 'apxeth', 'ueth', 'wheth', 'zeth', 'heth', 'veth', 'aeth', 'deth', 'yeth', 'yyeth', 'geth', 'qeth'],
                SOL: ['sol', 'wsol', 'msol', 'jitosol', 'bsol', 'stsol', 'scnsol', 'laine', 'vsol', 'jupsol', 'bonksol', 'lsol', 'cgntSOL', 'daoSOL', 'lainesol', 'picosol', 'pwrsol', 'hubsol', 'compasssol', 'hades', 'infinitysol', 'riskysol'],
                SUI: ['sui', 'wsui', 'afsui', 'hasui', 'vsui', 'stasui'],
                STABLE: ['usdc', 'usdt', 'dai', 'usdbc', 'frax', 'lusd', 'usds', 'crvusd', 'tusd', 'busd', 'gusd', 'usdp', 'usdd', 'pyusd', 'eusd', 'gho', 'mkusd', 'dola', 'susd', 'usd+', 'usdb', 'usdm', 'usde', 'usd0', 'fdusd', 'eur', 'eurt', 'eurc', 'ageur', 'ceur', 'usdk', 'usdn', 'mimatic', 'mai', 'alusd', 'mim', 'susdv2', 'susde', 'ousdt', 'ousdc', 'odai', 'wusdc', 'wusdt', 'wdai', 'usdce', 'usdtce', 'daie']
            },

            EXCLUDED: new Set(['btcbull', 'btcbear', 'ethbull', 'ethbear', 'btc2x', 'eth2x', 'btc3x', 'eth3x', 'btcup', 'btcdown', 'ethup', 'ethdown', 'ethfi', 'etherfi', 'btcpay', 'ethpay', 'btcdao', 'ethdao', 'btcix', 'ethix', 'methane', 'methanol', 'ethanol', 'ethernet', 'synthesis', 'synthetic', 'aesthetics', 'bethel', 'beth', 'elizabeth', 'macbeth'])
        };

        const ASSET_MAP = {};
        Object.entries(CONFIG.ASSETS).forEach(([cls, tokens]) => {
            tokens.forEach(t => ASSET_MAP[t.toLowerCase().replace(/\./g, '')] = cls);
        });

        // ============================================
        // STATE
        // ============================================
        const state = {
            pools: new Map(),
            poolHistory: new Map(),
            loadedNetworks: new Set(),
            isLoading: false,
            debugLogs: [],
            apiCalls: 0,
            lastApiCalls: {},
            sections: {}
        };

        CONFIG.SECTIONS.forEach(s => {
            state.sections[s.id] = {
                networks: [...CONFIG.INITIAL_NETWORKS],
                timeframe: '24h',
                sortField: 'utilization',
                sortDir: 'desc',
                isFastSection: false
            };
        });

        // ============================================
        // UTILITIES
        // ============================================
        const sleep = ms => new Promise(r => setTimeout(r, ms));

        function log(msg, type = 'info') {
            const ts = new Date().toLocaleTimeString();
            state.debugLogs.push({ ts, type, msg });
            if (state.debugLogs.length > 500) state.debugLogs = state.debugLogs.slice(-400);
            console.log(`[${ts}] [${type.toUpperCase()}] ${msg}`);
            renderDebugLog();
        }

        function renderDebugLog() {
            const el = document.getElementById('debug-log');
            if (el) {
                el.innerHTML = state.debugLogs.map(l =>
                    `<div class="log-${l.type}">[${l.ts}] ${l.msg}</div>`
                ).join('');
                el.scrollTop = el.scrollHeight;
            }
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str || '';
            return div.innerHTML;
        }

        function formatUsd(val) {
            if (!val && val !== 0) return '$0.00';
            if (val >= 1e9) return '$' + (val / 1e9).toFixed(2) + 'B';
            if (val >= 1e6) return '$' + (val / 1e6).toFixed(2) + 'M';
            if (val >= 1e3) return '$' + (val / 1e3).toFixed(1) + 'K';
            return '$' + val.toFixed(2);
        }

        function formatUtilization(util) {
            const pct = util * 100;
            if (pct >= 100) return pct.toFixed(0) + '%';
            if (pct >= 10) return pct.toFixed(1) + '%';
            return pct.toFixed(2) + '%';
        }

        function updateHeaderStatus(msg, type = 'info', loading = false) {
            const el = document.getElementById('header-status');
            if (!el) return;
            if (loading) {
                el.innerHTML = `
                    <span class="loading-indicator">
                        <span class="spinner spinner-sm"></span>
                        ${escapeHtml(msg)}
                    </span>
                `;
            } else if (type === 'error') {
                el.innerHTML = `<span class="error-indicator">${escapeHtml(msg)}</span>`;
            } else if (type === 'success') {
                const poolCount = state.pools.size;
                const networkCount = state.loadedNetworks.size;
                el.innerHTML = `
                    <span class="pool-count">${poolCount}</span> pools from
                    <span class="network-count">${networkCount}</span> networks
                `;
            } else {
                el.innerHTML = escapeHtml(msg);
            }
        }

        function updateProgress(pct) {
            const container = document.getElementById('progress-container');
            const bar = document.getElementById('progress-bar');
            if (pct > 0 && pct < 100) {
                container.classList.remove('hidden');
                bar.style.width = pct + '%';
            } else {
                container.classList.add('hidden');
                bar.style.width = '0%';
            }
        }

        function getProtocolBadgeStyle(name) {
            let hash = 0;
            const str = name.toLowerCase();
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            const hue = Math.abs(hash % 35) + 10; 
            const color = `hsl(${hue}, 85%, 45%)`;
            return {
                color: color,
                backgroundColor: `hsla(${hue}, 85%, 25%, 0.4)`
            };
        }

        // ============================================
        // TOKEN FORMATTING
        // ============================================
        function formatTokenSymbol(symbol) {
            if (!symbol) return '';
            const original = symbol.trim();
            const upper = original.toUpperCase();
            const lower = original.toLowerCase();

            if (upper === 'SOL' || upper.endsWith('SOL')) {
                const solIndex = upper.indexOf('SOL');
                const prefix = original.substring(0, solIndex).toLowerCase();
                const suffix = original.substring(solIndex + 3).toLowerCase();
                let html = '';
                if (prefix) html += `<span class="token-prefix">${escapeHtml(prefix)}</span>`;
                html += `<span class="token-sol">SOL</span>`;
                if (suffix) html += `<span class="token-prefix">${escapeHtml(suffix)}</span>`;
                return html;
            }
            if (upper === 'SUI' || upper.endsWith('SUI')) {
                const suiIndex = upper.indexOf('SUI');
                const prefix = original.substring(0, suiIndex).toLowerCase();
                let html = '';
                if (prefix) html += `<span class="token-prefix">${escapeHtml(prefix)}</span>`;
                html += `<span class="token-sui">SUI</span>`;
                return html;
            }
            const btcIndex = upper.indexOf('BTC');
            if (btcIndex !== -1 && !CONFIG.EXCLUDED.has(lower)) {
                const prefix = original.substring(0, btcIndex).toLowerCase();
                const suffix = original.substring(btcIndex + 3).toLowerCase();
                let html = '';
                if (prefix) html += `<span class="token-prefix">${escapeHtml(prefix)}</span>`;
                html += `<span class="token-btc">BTC</span>`;
                if (suffix) html += `<span class="token-prefix">${escapeHtml(suffix)}</span>`;
                return html;
            }
            const ethIndex = upper.indexOf('ETH');
            if (ethIndex !== -1 && !CONFIG.EXCLUDED.has(lower)) {
                const prefix = original.substring(0, ethIndex).toLowerCase();
                const suffix = original.substring(ethIndex + 3).toLowerCase();
                let html = '';
                if (prefix) html += `<span class="token-prefix">${escapeHtml(prefix)}</span>`;
                html += `<span class="token-eth">ETH</span>`;
                if (suffix) html += `<span class="token-prefix">${escapeHtml(suffix)}</span>`;
                return html;
            }
            const normalized = lower.replace(/\./g, '');
            if (normalized === 'usdc' || normalized === 'usdce') {
                return `<span class="token-usdc">${escapeHtml(upper)}</span>`;
            }
            if (normalized === 'usdt' || normalized === 'usdtce' || normalized === 'usdte') {
                return `<span class="token-usdt">${escapeHtml(upper)}</span>`;
            }
            if (normalized === 'dai' || normalized === 'daie') {
                return `<span class="token-dai">${escapeHtml(upper)}</span>`;
            }
            if (ASSET_MAP[normalized] === 'STABLE') {
                return `<span class="token-stable">${escapeHtml(upper)}</span>`;
            }
            return escapeHtml(upper);
        }

        function colorizePoolName(name) {
            if (!name) return '';
            const parts = name.split(/(\s*[\/\-]\s*)/);
            return parts.map(part => {
                const trimmed = part.trim();
                if (/^^[\/\-\s]+$/.test(part)) return escapeHtml(part);
                if (/^^\d+\.?\d*%?$/.test(trimmed)) {
                    return `<span style="opacity:0.6">${escapeHtml(trimmed)}</span>`;
                }
                return formatTokenSymbol(trimmed);
            }).join('');
        }

        // ============================================
        // DATA SOURCE CLASS (GECKOTERMINAL ONLY)
        // ============================================
        class DataSource {
            constructor(name, network) {
                this.name = name;
                this.network = network;
                this.rateLimitMs = CONFIG.RATE_LIMITS.DEFAULT;
            }

            async rateLimit() {
                const key = this.name;
                const now = Date.now();
                const lastCall = state.lastApiCalls[key] || 0;
                const elapsed = now - lastCall;
                if (elapsed < this.rateLimitMs) {
                    await sleep(this.rateLimitMs - elapsed);
                }
                state.lastApiCalls[key] = Date.now();
                state.apiCalls++;
            }

            async fetchWithRetry(url, options = {}, retries = CONFIG.MAX_RETRIES) {
                await this.rateLimit();

                for (let attempt = 1; attempt <= retries; attempt++) {
                    try {
                        const ctrl = new AbortController();
                        const timeout = setTimeout(() => ctrl.abort(), CONFIG.TIMEOUT_MS);

                        const res = await fetch(url, {
                            ...options,
                            signal: ctrl.signal,
                            headers: { Accept: 'application/json', ...options.headers }
                        });
                        clearTimeout(timeout);

                        if (res.status === 429) {
                            log(`[${this.name}] Rate limited, waiting 10s...`, 'warn');
                            await sleep(10000);
                            continue;
                        }

                        if (!res.ok) throw new Error(`HTTP ${res.status}`);
                        return await res.json();
                    } catch (err) {
                        log(`[${this.name}] Error (${attempt}/${retries}): ${err.message}`, 'warn');
                        if (attempt < retries) {
                            await sleep(CONFIG.RETRY_DELAY_MS * attempt);
                        }
                    }
                }
                return null;
            }

            async discoverPools(onProgress) { throw new Error('Not implemented'); }
            async fetchHistoricalVolume(pool, days) { throw new Error('Not implemented'); }
        }

        class GeckoTerminalSource extends DataSource {
            constructor(network) {
                super('GeckoTerminal', network);
                this.baseUrl = CONFIG.APIS.GECKOTERMINAL;
                this.rateLimitMs = CONFIG.RATE_LIMITS.GECKOTERMINAL;
            }

            async discoverPools(onProgress) {
                const discovered = new Map();
                
                // Helper to add pool if it passes filters
                const checkAndAddPool = (poolData) => {
                    const norm = this.normalizePool(poolData);
                    if (norm) {
                        const existing = discovered.get(norm.id);
                        // Prefer pool with higher liquidity if duplicate found
                        if (!existing || existing.liquidity < norm.liquidity) {
                            discovered.set(norm.id, norm);
                        }
                    }
                };

                log(`[GeckoTerminal] Starting discovery for ${this.network}...`, 'gecko');
                
                // 1. Fetch Top Pools via Pagination
                for (let page = 1; page <= CONFIG.MAX_PAGES_PER_NETWORK; page++) {
                    const url = `${this.baseUrl}/networks/${this.network}/pools?page=${page}`;
                    const res = await this.fetchWithRetry(url);

                    if (res && res.data && Array.isArray(res.data)) {
                        if (res.data.length === 0) break; // No more pools

                        res.data.forEach(pool => checkAndAddPool(pool));
                        
                        // Extract included data once per page to map tokens/dexes if needed, 
                        // though normalizePool handles the full object context.
                    } else {
                        log(`[GeckoTerminal] Failed to fetch page ${page} for ${this.network}`, 'warn');
                        break;
                    }
                    
                    // Small progress bump per page
                    if (onProgress) onProgress(5); 
                }

                // 2. Fetch Specific Search Queries
                const allQueries = Object.values(CONFIG.SEARCHES).flat();
                const uniqueQueries = [...new Set(allQueries)];
                
                log(`[GeckoTerminal] Searching ${uniqueQueries.length} queries for ${this.network}...`, 'gecko');

                for (const query of uniqueQueries) {
                    const url = `${this.baseUrl}/search/pools?query=${encodeURIComponent(query)}&network=${this.network}`;
                    const res = await this.fetchWithRetry(url);

                    if (res && res.data && Array.isArray(res.data)) {
                        res.data.forEach(pool => checkAndAddPool(pool));
                    }
                    if (onProgress) onProgress(1);
                }

                log(`[GeckoTerminal] Discovery complete for ${this.network}. Found ${discovered.size} pools.`, 'gecko');
                return discovered;
            }

            normalizePool(raw) {
                // GeckoTerminal API: JSON API format
                // attributes contains: address, name, reserve_in_usd, volume_usd { h24 }
                // relationships contains: dex, base_token, quote_token
                // included contains: full objects for dex and tokens

                const attr = raw.attributes;
                const rel = raw.relationships;
                
                if (!attr || !rel) return null;

                const liquidity = parseFloat(attr.reserve_in_usd || 0);
                const volume24h = parseFloat(attr.volume_usd?.h24 || 0);

                if (liquidity < CONFIG.MIN_LIQUIDITY || volume24h < CONFIG.MIN_VOLUME_24H) {
                    return null;
                }

                // Build included map
                const includedMap = {};
                if (raw.included && Array.isArray(raw.included)) {
                    raw.included.forEach(item => {
                        includedMap[item.id] = item.attributes;
                    });
                }

                // Get Token Details
                const getToken = (relField) => {
                    const tokenRel = rel[relField]?.data;
                    if (!tokenRel) return { symbol: '???' };
                    const tokenAttr = includedMap[tokenRel.id];
                    return {
                        symbol: tokenAttr?.symbol || '???',
                        address: tokenAttr?.address || tokenRel.id
                    };
                };

                const token0 = getToken('base_token');
                const token1 = getToken('quote_token');

                // Get Dex Details
                let protocol = 'DEX';
                const dexRel = rel.dex?.data;
                if (dexRel && includedMap[dexRel.id]) {
                    protocol = includedMap[dexRel.id].name || 'DEX';
                }

                // Fee Tier parsing
                let fee = 0.003; // Default 0.3%
                if (attr.fee_tier) {
                    const feeStr = String(attr.fee_tier);
                    // Try to handle "0.3", "3000", "0.05", "500"
                    const parsedFee = parseFloat(feeStr);
                    if (!isNaN(parsedFee)) {
                        if (parsedFee > 1) {
                            // Likely basis points (e.g. 3000 -> 0.3)
                            fee = parsedFee / 10000;
                        } else {
                            // Likely decimal (e.g. 0.3 -> 0.3)
                            fee = parsedFee;
                        }
                    }
                }

                const explorerBase = CONFIG.EXPLORERS[this.network] || '#';
                const explorerUrl = explorerBase + attr.address;
                const poolUrl = `https://www.geckoterminal.com/${this.network}/pools/${attr.address}`;

                return {
                    id: `${this.network}-${attr.address}`,
                    chainId: this.network,
                    address: attr.address,
                    token0: token0,
                    token1: token1,
                    name: attr.name,
                    liquidity: liquidity,
                    volume24h: volume24h,
                    fee: fee,
                    protocol: protocol,
                    explorerUrl: explorerUrl,
                    poolUrl: poolUrl,
                    dataSource: 'geckoterminal'
                };
            }

            async fetchHistoricalVolume(pool, days) {
                // pool.id is "network-address"
                const parts = pool.id.split('-');
                if (parts.length < 2) return 0;
                
                const network = parts[0];
                const address = parts.slice(1).join('-'); // Rejoin in case address had hyphens (unlikely for GT but safe)

                // Aggregate=1 means daily candles. Limit=days
                const url = `${this.baseUrl}/networks/${network}/pools/${address}/ohlcv/day?aggregate=1&limit=${days}&currency=usd`;
                
                const res = await this.fetchWithRetry(url);
                if (res && res.data && Array.isArray(res.data)) {
                    let totalVolume = 0;
                    res.data.forEach(candle => {
                        totalVolume += parseFloat(candle.attributes.volume || 0);
                    });
                    return totalVolume;
                }
                return 0;
            }
        }

        // ============================================
        // APP LOGIC
        // ============================================
        
        function createDataSource(network) {
            return new GeckoTerminalSource(network);
        }

        function getHistoricalVolumeSource(network) {
            return new GeckoTerminalSource(network);
        }

        async function discoverPoolsForNetwork(network, progressCallback) {
            const source = createDataSource(network);
            const discovered = await source.discoverPools(progressCallback);
            
            let addedCount = 0;
            discovered.forEach(pool => {
                state.pools.set(pool.id, pool);
                addedCount++;
            });

            return addedCount;
        }

        async function fetchPoolHistory(sectionId) {
            const section = state.sections[sectionId];
            const days = CONFIG.TIMEFRAMES[section.timeframe].days;

            // Filter pools for this section
            const sectionPools = Array.from(state.pools.values()).filter(p => {
                if (!section.networks.includes(p.chainId)) return false;
                // Match logic based on section ID
                const symbols = [p.token0.symbol.toLowerCase(), p.token1.symbol.toLowerCase()];
                const name = p.name.toLowerCase();
                
                if (sectionId === 'btc-stable') {
                    return symbols.some(s => CONFIG.ASSETS.BTC.includes(s)) && symbols.some(s => CONFIG.ASSETS.STABLE.includes(s));
                }
                if (sectionId === 'eth-stable') {
                    return symbols.some(s => CONFIG.ASSETS.ETH.includes(s)) && symbols.some(s => CONFIG.ASSETS.STABLE.includes(s));
                }
                if (sectionId === 'btc-eth') {
                    return symbols.some(s => CONFIG.ASSETS.BTC.includes(s)) && symbols.some(s => CONFIG.ASSETS.ETH.includes(s));
                }
                if (sectionId === 'wrapped') {
                    return symbols.some(s => CONFIG.ASSETS.ETH.includes(s)) && symbols.some(s => CONFIG.ASSETS.ETH.includes(s)) && !symbols.some(s => CONFIG.ASSETS.STABLE.includes(s));
                }
                if (sectionId === 'stable-stable') {
                    return symbols.some(s => CONFIG.ASSETS.STABLE.includes(s)) && symbols.some(s => CONFIG.ASSETS.STABLE.includes(s));
                }
                return false;
            });

            // Dedupe pools that need fetching (avoid fetching same pool for different sections if timeframe is same)
            // But here we fetch per section context. 
            // Optimization: Check if we already have history for this pool ID for these specific days?
            // For simplicity, we re-fetch or update. A simple cache key: `${poolId}-${days}`
            
            const fetchTasks = sectionPools.map(async (pool) => {
                const cacheKey = `${pool.id}-${days}`;
                if (state.poolHistory.has(cacheKey)) {
                    return state.poolHistory.get(cacheKey);
                }

                const source = getHistoricalVolumeSource(pool.chainId);
                const vol = await source.fetchHistoricalVolume(pool, days);
                state.poolHistory.set(cacheKey, vol);
                return vol;
            });

            const volumes = await Promise.all(fetchTasks);
            
            // Attach volumes to a temporary map for rendering
            const volumeMap = new Map();
            sectionPools.forEach((p, i) => {
                volumeMap.set(p.id, volumes[i]);
            });

            return { pools: sectionPools, volumeMap };
        }

        function calculateAPR(pool, volume, timeframe) {
            // APR = (Volume * Fee * 365) / Liquidity
            // Note: Volume is already aggregated for the timeframe days
            const days = CONFIG.TIMEFRAMES[timeframe].days;
            const annualizedVolume = (volume / days) * 365;
            const feeRevenue = annualizedVolume * pool.fee;
            if (pool.liquidity === 0) return 0;
            return feeRevenue / pool.liquidity;
        }

        function calculateUtilization(pool, timeframe, volume) {
            const days = CONFIG.TIMEFRAMES[timeframe].days;
            const avgDailyVolume = volume / days;
            if (pool.liquidity === 0) return 0;
            return avgDailyVolume / pool.liquidity;
        }

        async function refreshData() {
            if (state.isLoading) return;
            state.isLoading = true;
            state.pools.clear();
            state.poolHistory.clear();
            state.loadedNetworks.clear();
            
            document.getElementById('dashboard-grid').innerHTML = '';
            document.getElementById('stablecoin-section-wrapper').innerHTML = '';
            updateHeaderStatus('Discovering pools...', 'info', true);
            updateProgress(1);

            try {
                // 1. Discovery Phase
                const networksToLoad = CONFIG.ALL_SUPPORTED_NETWORKS; // Or a subset if user prefers
                let networkIndex = 0;
                
                for (const network of networksToLoad) {
                    updateHeaderStatus(`Scanning ${CONFIG.NETWORK_NAMES[network] || network}...`, 'info', true);
                    const count = await discoverPoolsForNetwork(network, (pctInc) => {
                         // Aggregate progress
                         const totalProgress = ((networkIndex / networksToLoad.length) * 70) + (pctInc / networksToLoad.length);
                         updateProgress(Math.min(totalProgress, 70));
                    });
                    if (count > 0) {
                        state.loadedNetworks.add(network);
                    }
                    networkIndex++;
                }

                updateHeaderStatus(`Found ${state.pools.size} pools. Loading history...`, 'info', true);
                updateProgress(75);

                // 2. UI Initialization
                initDashboardUI();

                // 3. Fetch Data for Initial Render (all sections)
                const updatePromises = CONFIG.SECTIONS.map(section => updateSectionData(section.id));
                await Promise.all(updatePromises);

                updateHeaderStatus('Complete', 'success');
                updateProgress(100);
                document.getElementById('last-updated').textContent = `Updated: ${new Date().toLocaleTimeString()}`;

            } catch (err) {
                log(`Critical Error: ${err.message}`, 'error');
                updateHeaderStatus('Error loading data', 'error');
            } finally {
                state.isLoading = false;
            }
        }

        function initDashboardUI() {
            const grid = document.getElementById('dashboard-grid');
            const stableWrapper = document.getElementById('stablecoin-section-wrapper');
            
            grid.innerHTML = '';
            stableWrapper.innerHTML = '';

            CONFIG.SECTIONS.forEach(section => {
                const container = section.grid ? grid : stableWrapper;
                const sectionEl = document.createElement('div');
                sectionEl.className = 'pair-section' + (section.grid ? '' : ' full-width');
                sectionEl.id = `section-${section.id}`;
                
                sectionEl.innerHTML = `
                    <div class="section-header">
                        <div class="section-title">${section.title} <span class="pool-count" id="count-${section.id}">0</span></div>
                        <div class="section-controls">
                            <div class="network-selector">
                                <button class="network-btn" id="net-btn-${section.id}">
                                    Networks <span class="network-badge" id="net-badge-${section.id}">0</span>
                                    <span class="network-arrow">▼</span>
                                </button>
                                <div class="network-dropdown" id="net-dd-${section.id}">
                                    <div class="dropdown-header">
                                        <span>Select Networks</span>
                                        <button class="reset-networks" data-section="${section.id}">Reset</button>
                                    </div>
                                    <div class="dropdown-content" id="net-list-${section.id}"></div>
                                    <div class="dropdown-footer">
                                        <div class="dropdown-footer-info">Active: <span class="to-load">${state.sections[section.id].networks.length}</span></div>
                                        <div class="dropdown-footer-buttons">
                                            <button class="btn btn-sm apply-networks" data-section="${section.id}">Apply</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="timeframe-toggle">
                                ${Object.keys(CONFIG.TIMEFRAMES).map(tf => `
                                    <button class="tf-btn ${tf === state.sections[section.id].timeframe ? 'active' : ''}" 
                                            data-section="${section.id}" data-tf="${tf}">${tf}</button>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    <div class="section-content">
                        <div class="table-container">
                            <table class="pool-table">
                                <thead>
                                    <tr>
                                        <th class="col-chain" data-sort="chainId">Chain</th>
                                        <th class="col-protocol">Protocol</th>
                                        <th class="col-pool" data-sort="name">Pool</th>
                                        <th class="col-fee" data-sort="fee">Fee</th>
                                        <th class="col-liquidity" data-sort="liquidity">Liq</th>
                                        <th class="col-volume" data-sort="volume">Vol</th>
                                        <th class="col-util" data-sort="utilization">Util</th>
                                        <th class="col-apr" data-sort="apr">APR</th>
                                    </tr>
                                </thead>
                                <tbody id="tbody-${section.id}"></tbody>
                            </table>
                        </div>
                    </div>
                    <div class="section-overlay" id="overlay-${section.id}">
                        <div class="spinner"></div>
                        <div class="section-overlay-text">Loading Data...</div>
                    </div>
                `;
                container.appendChild(sectionEl);
                
                initSectionControls(section.id);
            });
        }

        function initSectionControls(sectionId) {
            // Timeframe buttons
            const tfBtns = document.querySelectorAll(`.tf-btn[data-section="${sectionId}"]`);
            tfBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const tf = btn.dataset.tf;
                    state.sections[sectionId].timeframe = tf;
                    
                    // Update UI classes
                    tfBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    updateSectionData(sectionId);
                });
            });

            // Network Selector
            const netBtn = document.getElementById(`net-btn-${sectionId}`);
            const netDd = document.getElementById(`net-dd-${sectionId}`);
            const netList = document.getElementById(`net-list-${sectionId}`);
            const applyBtn = document.querySelector(`.apply-networks[data-section="${sectionId}"]`);
            const resetBtn = document.querySelector(`.reset-networks[data-section="${sectionId}"]`);

            // Populate list
            const renderNetworkList = () => {
                const selected = new Set(state.sections[sectionId].networks);
                netList.innerHTML = '';
                
                Object.entries(CONFIG.NETWORK_GROUPS).forEach(([groupName, nets]) => {
                    const groupLabel = document.createElement('div');
                    groupLabel.className = 'network-group-label';
                    groupLabel.textContent = groupName;
                    netList.appendChild(groupLabel);

                    nets.forEach(net => {
                        const item = document.createElement('div');
                        const isSelected = selected.has(net.id);
                        item.className = `network-item ${isSelected ? 'selected' : ''}`;
                        item.innerHTML = `
                            <div class="network-checkbox">${isSelected ? '✓' : ''}</div>
                            <div class="network-name">${net.name}</div>
                            ${net.fast ? '<span class="fast-tag">Fast</span>' : ''}
                        `;
                        item.onclick = () => {
                            if (selected.has(net.id)) selected.delete(net.id);
                            else selected.add(net.id);
                            state.sections[sectionId].networks = Array.from(selected);
                            renderNetworkList();
                        };
                        netList.appendChild(item);
                    });
                });
                
                // Update badge count
                document.getElementById(`net-badge-${sectionId}`).textContent = selected.size;
            };
            renderNetworkList();

            // Toggle dropdown
            netBtn.onclick = (e) => {
                e.stopPropagation();
                const isOpen = netDd.classList.contains('open');
                // Close others
                document.querySelectorAll('.network-dropdown.open').forEach(el => el.classList.remove('open'));
                document.querySelectorAll('.network-btn.open').forEach(el => el.classList.remove('open'));
                
                if (!isOpen) {
                    netDd.classList.add('open');
                    netBtn.classList.add('open');
                }
            };

            // Apply button
            applyBtn.onclick = () => {
                netDd.classList.remove('open');
                netBtn.classList.remove('open');
                updateSectionData(sectionId);
            };

            // Reset button
            resetBtn.onclick = () => {
                state.sections[sectionId].networks = [...CONFIG.INITIAL_NETWORKS];
                renderNetworkList();
                updateSectionData(sectionId);
            };

            // Close dropdowns on click outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.network-selector')) {
                    netDd.classList.remove('open');
                    netBtn.classList.remove('open');
                }
            });

            // Sorting
            const table = document.querySelector(`#section-${sectionId} .pool-table`);
            table.querySelectorAll('th[data-sort]').forEach(th => {
                th.onclick = () => {
                    const field = th.dataset.sort;
                    const current = state.sections[sectionId].sortField;
                    const dir = (current === field && state.sections[sectionId].sortDir === 'desc') ? 'asc' : 'desc';
                    
                    state.sections[sectionId].sortField = field;
                    state.sections[sectionId].sortDir = dir;
                    
                    renderSectionTable(sectionId);
                };
            });
        }

        async function updateSectionData(sectionId) {
            const overlay = document.getElementById(`overlay-${sectionId}`);
            overlay.classList.add('active');

            try {
                const { pools, volumeMap } = await fetchPoolHistory(sectionId);
                
                // Attach calculated metrics
                const enrichedPools = pools.map(pool => {
                    const volume = volumeMap.get(pool.id) || 0;
                    const section = state.sections[sectionId];
                    const apr = calculateAPR(pool, volume, section.timeframe);
                    const util = calculateUtilization(pool, section.timeframe, volume);
                    
                    return {
                        ...pool,
                        displayVolume: volume,
                        displayAPR: apr,
                        displayUtil: util
                    };
                });

                state.sections[sectionId].renderData = enrichedPools;
                renderSectionTable(sectionId);

            } catch (err) {
                log(`Error updating section ${sectionId}: ${err.message}`, 'error');
            } finally {
                overlay.classList.remove('active');
            }
        }

        function renderSectionTable(sectionId) {
            const section = state.sections[sectionId];
            const tbody = document.getElementById(`tbody-${sectionId}`);
            const countSpan = document.getElementById(`count-${sectionId}`);
            
            if (!section.renderData) return;

            const { sortField, sortDir, renderData } = section;

            // Sort
            renderData.sort((a, b) => {
                let valA, valB;
                if (sortField === 'chainId') {
                    valA = a.chainId; valB = b.chainId;
                } else if (sortField === 'name') {
                    valA = a.name; valB = b.name;
                } else if (sortField === 'fee') {
                    valA = a.fee; valB = b.fee;
                } else if (sortField === 'liquidity') {
                    valA = a.liquidity; valB = b.liquidity;
                } else if (sortField === 'volume') {
                    valA = a.displayVolume; valB = b.displayVolume;
                } else if (sortField === 'utilization') {
                    valA = a.displayUtil; valB = b.displayUtil;
                } else if (sortField === 'apr') {
                    valA = a.displayAPR; valB = b.displayAPR;
                }

                if (typeof valA === 'string') {
                    return sortDir === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                }
                return sortDir === 'asc' ? valA - valB : valB - valA;
            });

            // Update Count
            countSpan.textContent = renderData.length;

            // Update Header Sort Icons
            const table = document.querySelector(`#section-${sectionId} .pool-table`);
            table.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                if (th.dataset.sort === sortField) {
                    th.classList.add(sortDir === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });

            // Render Rows
            if (renderData.length === 0) {
                tbody.innerHTML = `<tr><td colspan="8" class="no-data">No pools found for this selection.</td></tr>`;
                return;
            }

            // Limit rows for performance
            const displayRows = renderData.slice(0, 50);

            tbody.innerHTML = displayRows.map(pool => {
                const protocolStyle = getProtocolBadgeStyle(pool.protocol);
                const maxLiquidity = 5000000; // for bar width scaling
                
                // Determine APR color
                let aprClass = 'apr-low';
                if (pool.displayAPR > 0.5) aprClass = 'apr-moderate';
                if (pool.displayAPR > 1.0) aprClass = 'apr-good';
                if (pool.displayAPR > 2.0) aprClass = 'apr-excellent';

                // Determine Utilization color
                let utilClass = 'utilization-low';
                if (pool.displayUtil > 0.1) utilClass = 'utilization-moderate';
                if (pool.displayUtil > 0.25) utilClass = 'utilization-high';
                if (pool.displayUtil > 0.50) utilClass = 'utilization-excellent';

                const feePct = (pool.fee * 100).toFixed(2);
                const feeClass = pool.fee < 0.001 ? 'fee-low' : (pool.fee > 0.005 ? 'fee-high' : 'fee-medium');

                const liqWidth = Math.min((pool.liquidity / maxLiquidity) * 100, 100);

                return `
                    <tr>
                        <td class="col-chain">${CONFIG.NETWORK_NAMES[pool.chainId] || pool.chainId.toUpperCase()}</td>
                        <td class="col-protocol">
                            <span class="protocol-badge" style="color:${protocolStyle.color}; background-color:${protocolStyle.backgroundColor}">
                                ${escapeHtml(pool.protocol)}
                            </span>
                        </td>
                        <td class="col-pool">
                            <div class="pool-cell">
                                <a href="${pool.poolUrl}" target="_blank" class="pool-link" title="${escapeHtml(pool.name)}">
                                    ${colorizePoolName(pool.name)}
                                </a>
                                <a href="${pool.explorerUrl}" target="_blank" class="explorer-link" title="Explorer">⬈</a>
                            </div>
                        </td>
                        <td class="col-fee"><span class="fee-badge ${feeClass}">${feePct}%</span></td>
                        <td class="col-liquidity liquidity-cell">
                            <div class="liquidity-bar" style="width: ${liqWidth}%"></div>
                            <span class="liquidity-value">${formatUsd(pool.liquidity)}</span>
                        </td>
                        <td class="col-volume volume-cell">${formatUsd(pool.displayVolume)} <span class="tf-indicator">${CONFIG.TIMEFRAMES[state.sections[sectionId].timeframe].label}</span></td>
                        <td class="col-util utilization-value ${utilClass}">${formatUtilization(pool.displayUtil)}</td>
                        <td class="col-apr apr-value ${aprClass}">${(pool.displayAPR * 100).toFixed(1)}%</td>
                    </tr>
                `;
            }).join('');
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        document.getElementById('refresh-btn').addEventListener('click', refreshData);
        
        document.getElementById('debug-toggle').addEventListener('click', () => {
            const sec = document.getElementById('debug-section');
            sec.classList.toggle('hidden');
        });

        document.getElementById('clear-debug').addEventListener('click', () => {
            state.debugLogs = [];
            renderDebugLog();
        });

        // Start
        refreshData();

    })();
    </script>
</body>
</html>
