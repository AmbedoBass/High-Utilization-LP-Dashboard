<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC LP Utilization Dashboard</title>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --bg-color-lighter: #111111;
            --surface-color: #1a1a1a;
            --primary-text-color: #e0e0e0;
            --secondary-text-color: #888888;
            --border-color: #2a2a2a;
            --hover-bg-color: #222222;
            --success-color: #4ade80;
            --warning-color: #fbbf24;
            --error-color: #f87171;
            --btc-color: #f7931a;
            --eth-color: #87CEEB;
            --usdc-color: #4A90E2;
            --usdt-color: #5CB85C;
            --dai-color: #D4A76A;
            --apr-low: #1a5f2a;
            --apr-moderate: #2d8a3e;
            --apr-good: #48bb5c;
            --apr-excellent: #4ade80;
            --util-low: #4a3a6b;
            --util-moderate: #7c5dac;
            --util-high: #a78bfa;
            --util-excellent: #c4b5fd;
            --section-bg: #0f0f0f;
            --section-border: #2a2a2a;
            --section-header-bg: #151515;
            --section-th-bg: #121212;
            --link-color: #999999;
            --link-color-hover: #cccccc;
            --geckoterminal-color: #7c3aed;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-text-color);
            line-height: 1.5;
            min-height: 100vh;
        }

        header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-color-lighter);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 1rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .header-left h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary-text-color);
            margin-bottom: 0.4rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header-left h1 .btc-icon {
            color: var(--btc-color);
        }

        .header-left p {
            color: var(--secondary-text-color);
            font-size: 0.85rem;
            max-width: 500px;
        }

        .header-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.5rem;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-status {
            font-size: 0.8rem;
            color: var(--secondary-text-color);
            text-align: right;
        }

        .header-status .pool-count {
            color: var(--btc-color);
            font-weight: 600;
        }

        .header-status .network-count {
            color: var(--util-high);
            font-weight: 500;
        }

        .header-status .loading-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--warning-color);
        }

        main {
            padding: 1.5rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        footer {
            padding: 1rem 2rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.8rem;
            color: var(--secondary-text-color);
        }

        .data-source {
            margin-top: 0.4rem;
            font-size: 0.75rem;
            color: var(--geckoterminal-color);
        }

        .btn {
            background-color: #333333;
            color: #fff;
            border: 1px solid #444444;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background-color: #444444;
        }

        .btn:disabled {
            background-color: #222222;
            color: var(--secondary-text-color);
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: var(--btc-color);
            border-color: var(--btc-color);
        }

        .btn-primary:hover {
            background-color: #e8850f;
        }

        .btn-sm {
            padding: 0.35rem 0.75rem;
            font-size: 0.8rem;
        }

        .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--btc-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .spinner-sm {
            width: 12px;
            height: 12px;
            border-width: 1.5px;
        }

        .hidden {
            display: none !important;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Main Panel */
        .main-panel {
            background-color: var(--section-bg);
            border: 1px solid var(--section-border);
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            min-height: 500px;
            position: relative;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.25rem;
            background-color: var(--section-header-bg);
            border-bottom: 1px solid var(--section-border);
            gap: 1rem;
            flex-wrap: wrap;
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .panel-title .btc-icon {
            color: var(--btc-color);
            font-size: 1.3rem;
        }

        .pool-count-badge {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--secondary-text-color);
            background-color: var(--surface-color);
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
        }

        .panel-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        /* Load Status */
        .load-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-badge {
            font-size: 0.7rem;
            font-weight: 600;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        .status-badge.quick {
            background-color: rgba(251, 191, 36, 0.15);
            color: var(--warning-color);
        }

        .status-badge.full {
            background-color: rgba(74, 222, 128, 0.15);
            color: var(--success-color);
        }

        .load-more-btn {
            background-color: transparent;
            color: var(--util-high);
            border: 1px solid var(--util-moderate);
            padding: 0.25rem 0.6rem;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .load-more-btn:hover {
            background-color: var(--util-moderate);
            color: #fff;
        }

        .load-more-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Timeframe Toggle */
        .timeframe-toggle {
            display: flex;
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 3px;
            gap: 2px;
        }

        .tf-btn {
            background-color: transparent;
            color: var(--secondary-text-color);
            border: none;
            padding: 0.35rem 0.6rem;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .tf-btn:hover {
            background-color: var(--hover-bg-color);
            color: var(--primary-text-color);
        }

        .tf-btn.active {
            background-color: var(--btc-color);
            color: #fff;
        }

        /* Network Selector */
        .network-selector {
            position: relative;
        }

        .network-btn {
            background-color: var(--surface-color);
            color: var(--secondary-text-color);
            border: 1px solid var(--border-color);
            padding: 0.4rem 0.75rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .network-btn:hover {
            background-color: var(--hover-bg-color);
            color: var(--primary-text-color);
        }

        .network-btn.open {
            border-color: var(--btc-color);
        }

        .network-count-badge {
            background-color: var(--btc-color);
            color: #fff;
            font-size: 0.7rem;
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
            font-weight: 600;
        }

        .network-arrow {
            font-size: 0.6rem;
            transition: transform 0.2s ease;
        }

        .network-btn.open .network-arrow {
            transform: rotate(180deg);
        }

        .network-dropdown {
            position: fixed;
            width: 300px;
            max-width: calc(100vw - 20px);
            max-height: 500px;
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            z-index: 9999;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            display: none;
            flex-direction: column;
        }

        .network-dropdown.open {
            display: flex;
        }

        .dropdown-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.75rem;
            color: var(--secondary-text-color);
            text-transform: uppercase;
            letter-spacing: 0.03em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dropdown-header button {
            background: none;
            border: none;
            color: var(--btc-color);
            font-size: 0.7rem;
            cursor: pointer;
            padding: 0;
        }

        .dropdown-header button:hover {
            text-decoration: underline;
        }

        .dropdown-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem 0;
        }

        .network-group-label {
            font-size: 0.65rem;
            color: var(--secondary-text-color);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.6rem 1rem 0.3rem;
            opacity: 0.7;
        }

        .network-item {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        .network-item:hover {
            background-color: var(--hover-bg-color);
        }

        .network-item.selected {
            background-color: rgba(247, 147, 26, 0.1);
        }

        .network-item.not-loaded {
            opacity: 0.5;
        }

        .network-item.not-loaded:hover {
            background-color: rgba(251, 191, 36, 0.1);
            opacity: 0.7;
        }

        .network-checkbox {
            width: 16px;
            height: 16px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: #fff;
            background-color: var(--bg-color);
            flex-shrink: 0;
        }

        .network-item.selected .network-checkbox {
            background-color: var(--btc-color);
            border-color: var(--btc-color);
        }

        .network-name {
            font-size: 0.85rem;
            color: var(--primary-text-color);
            flex: 1;
        }

        .network-tag {
            font-size: 0.6rem;
            padding: 0.1rem 0.35rem;
            border-radius: 3px;
        }

        .network-tag.loaded {
            color: var(--success-color);
            background-color: rgba(74, 222, 128, 0.15);
        }

        .network-tag.not-loaded {
            color: var(--warning-color);
            background-color: rgba(251, 191, 36, 0.15);
        }

        .dropdown-footer {
            padding: 0.75rem 1rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.5rem;
        }

        .dropdown-footer-info {
            font-size: 0.75rem;
            color: var(--secondary-text-color);
        }

        .dropdown-footer-info .to-load {
            color: var(--warning-color);
            font-weight: 600;
        }

        .dropdown-footer-buttons {
            display: flex;
            gap: 0.5rem;
        }

        /* Table */
        .panel-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .table-container {
            flex: 1;
            overflow: auto;
        }

        .pool-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            table-layout: fixed;
        }

        .pool-table th,
        .pool-table td {
            padding: 0.65rem 0.85rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .pool-table .col-chain { width: 90px; }
        .pool-table .col-protocol { width: 100px; }
        .pool-table .col-type { width: 90px; }
        .pool-table .col-pool { width: 180px; }
        .pool-table .col-fee { width: 70px; }
        .pool-table .col-liquidity { width: 110px; text-align: right; }
        .pool-table .col-volume { width: 120px; text-align: right; }
        .pool-table .col-util { width: 85px; text-align: right; }
        .pool-table .col-apr { width: 100px; text-align: right; }

        .pool-table td:nth-child(6),
        .pool-table td:nth-child(7),
        .pool-table td:nth-child(8),
        .pool-table td:nth-child(9) {
            text-align: right;
        }

        .pool-table th {
            background-color: var(--section-th-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            color: var(--secondary-text-color);
        }

        .pool-table th:hover {
            color: var(--primary-text-color);
        }

        .pool-table th[data-sort]::after {
            content: ' ⇅';
            opacity: 0.4;
            font-size: 0.6em;
        }

        .pool-table th.sort-asc::after {
            content: ' ↑';
            opacity: 1;
        }

        .pool-table th.sort-desc::after {
            content: ' ↓';
            opacity: 1;
        }

        .pool-table tbody tr {
            transition: background-color 0.15s ease;
        }

        .pool-table tbody tr:hover {
            background-color: var(--hover-bg-color);
        }

        .pool-link {
            color: var(--link-color);
            text-decoration: none;
            font-weight: 500;
        }

        .pool-link:hover {
            color: var(--link-color-hover);
            text-decoration: underline;
        }

        .pool-cell {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .explorer-link {
            opacity: 0.4;
            font-size: 0.75rem;
            text-decoration: none;
        }

        .explorer-link:hover {
            opacity: 1;
        }

        /* Token Colors */
        .token-btc { color: var(--btc-color); font-weight: 600; }
        .token-eth { color: var(--eth-color); font-weight: 600; }
        .token-usdc { color: var(--usdc-color); font-weight: 600; }
        .token-usdt { color: var(--usdt-color); font-weight: 600; }
        .token-dai { color: var(--dai-color); font-weight: 600; }
        .token-stable { color: var(--primary-text-color); font-weight: 500; }
        .token-prefix { font-weight: 400; opacity: 0.8; }

        /* Badges */
        .protocol-badge {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 500;
            background-color: rgba(255, 255, 255, 0.08);
            max-width: 90px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .type-badge {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .type-badge.stable {
            background-color: rgba(74, 144, 226, 0.15);
            color: var(--usdc-color);
        }

        .type-badge.eth {
            background-color: rgba(135, 206, 235, 0.15);
            color: var(--eth-color);
        }

        .type-badge.wrapped {
            background-color: rgba(247, 147, 26, 0.15);
            color: var(--btc-color);
        }

        .fee-badge {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .fee-badge.fee-low {
            background-color: rgba(74, 222, 128, 0.2);
            color: var(--success-color);
        }

        .fee-badge.fee-medium {
            background-color: rgba(251, 191, 36, 0.2);
            color: var(--warning-color);
        }

        .fee-badge.fee-high {
            background-color: rgba(248, 113, 113, 0.2);
            color: var(--error-color);
        }

        /* Metrics */
        .liquidity-cell {
            position: relative;
            font-weight: 500;
        }

        .liquidity-bar {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            opacity: 0.3;
            border-radius: 2px;
            background: linear-gradient(90deg, rgba(247, 147, 26, 0.3), rgba(247, 147, 26, 0.5));
        }

        .liquidity-value {
            position: relative;
            z-index: 1;
        }

        .apr-value { font-weight: 600; }
        .apr-excellent { color: var(--apr-excellent); }
        .apr-good { color: var(--apr-good); }
        .apr-moderate { color: var(--apr-moderate); }
        .apr-low { color: var(--apr-low); }

        .utilization-value { font-weight: 600; }
        .utilization-excellent { color: var(--util-excellent); }
        .utilization-high { color: var(--util-high); }
        .utilization-moderate { color: var(--util-moderate); }
        .utilization-low { color: var(--util-low); }

        .tf-indicator {
            font-size: 0.65rem;
            opacity: 0.6;
            margin-left: 0.25rem;
        }

        .apr-basis {
            font-size: 0.6rem;
            font-weight: 400;
            opacity: 0.6;
            text-transform: none;
            letter-spacing: 0;
        }

        .no-data {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--secondary-text-color);
            font-size: 0.9rem;
        }

        /* Overlay */
        .panel-overlay {
            position: absolute;
            inset: 0;
            background-color: rgba(10, 10, 10, 0.92);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            border-radius: 6px;
        }

        .panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .panel-overlay .spinner {
            width: 32px;
            height: 32px;
            border-width: 3px;
            margin-bottom: 1rem;
        }

        .panel-overlay-text {
            font-size: 0.9rem;
            color: var(--secondary-text-color);
            text-align: center;
        }

        /* Scrollbar */
        .table-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .table-container::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        .table-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .table-container::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-text-color);
        }

        /* Responsive */
        @media (max-width: 900px) {
            header { padding: 1rem; }
            main { padding: 1rem; }
            
            .header-content {
                flex-direction: column;
                align-items: flex-start;
            }

            .header-right {
                align-items: flex-start;
                width: 100%;
            }

            .panel-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .panel-controls {
                width: 100%;
                justify-content: flex-start;
            }

            .pool-table th,
            .pool-table td {
                padding: 0.5rem 0.6rem;
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="header-left">
                <h1><span class="btc-icon">₿</span> BTC LP Utilization Dashboard</h1>
                <p>Discover high-utilization Bitcoin liquidity pools. Ranked by Utilization % (Daily Volume ÷ Liquidity). APR estimated from 24h volume × fee tier.</p>
            </div>
            <div class="header-right">
                <div class="header-controls">
                    <div class="header-status" id="header-status">
                        <span class="loading-indicator">
                            <span class="spinner spinner-sm"></span>
                            Initializing...
                        </span>
                    </div>
                    <button id="refresh-btn" class="btn btn-sm">Refresh</button>
                </div>
                <div id="last-updated" style="font-size: 0.75rem; color: var(--secondary-text-color);"></div>
            </div>
        </div>
    </header>

    <main>
        <div class="main-panel" id="main-panel">
            <div class="panel-header">
                <div class="panel-title">
                    <span class="btc-icon">₿</span>
                    <span>BTC Liquidity Pools</span>
                    <span class="pool-count-badge" id="pool-count">0 pools</span>
                </div>
                <div class="panel-controls">
                    <div class="load-status" id="load-status">
                        <span class="status-badge quick">Quick Load</span>
                        <button class="load-more-btn" id="load-full-btn">Load All Pools</button>
                    </div>
                    <div class="timeframe-toggle" id="timeframe-toggle">
                        <button class="tf-btn active" data-tf="24h">24h</button>
                        <button class="tf-btn" data-tf="7d">7d</button>
                        <button class="tf-btn" data-tf="30d">30d</button>
                    </div>
                    <div class="network-selector" id="network-selector">
                        <button class="network-btn" id="network-btn">
                            <span>Networks</span>
                            <span class="network-count-badge" id="network-badge">5</span>
                            <span class="network-arrow">▼</span>
                        </button>
                        <div class="network-dropdown" id="network-dropdown"></div>
                    </div>
                </div>
            </div>
            <div class="panel-content">
                <div class="table-container">
                    <table class="pool-table">
                        <thead>
                            <tr>
                                <th class="col-chain" data-sort="chain">Chain</th>
                                <th class="col-protocol" data-sort="protocol">Protocol</th>
                                <th class="col-type" data-sort="pairType">Type</th>
                                <th class="col-pool" data-sort="name">Pool</th>
                                <th class="col-fee" data-sort="fee">Fee</th>
                                <th class="col-liquidity" data-sort="liquidity">Liquidity</th>
                                <th class="col-volume" data-sort="displayVolume">Volume</th>
                                <th class="col-util" data-sort="utilization">Util %</th>
                                <th class="col-apr" data-sort="apr">APR <span class="apr-basis">(24h)</span></th>
                            </tr>
                        </thead>
                        <tbody id="pool-tbody"></tbody>
                    </table>
                    <div class="no-data hidden" id="no-data">No BTC pools found. Try adding more networks.</div>
                </div>
            </div>
            <div class="panel-overlay" id="panel-overlay">
                <div class="spinner"></div>
                <div class="panel-overlay-text" id="overlay-text">Loading pools...</div>
            </div>
        </div>
    </main>

    <footer>
        <p>Always DYOR. Data refreshes on demand.</p>
        <div class="data-source">● Powered by GeckoTerminal API</div>
    </footer>

    <script>
    (function() {
        'use strict';

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            API_BASE: 'https://api.geckoterminal.com/api/v2',
            RATE_LIMIT_MS: 2200,
            MAX_RETRIES: 3,
            TIMEOUT_MS: 25000,
            MIN_LIQUIDITY: 50000,
            MIN_VOLUME: 1000,
            DEFAULT_FEE: 0.3,
            QUICK_PAGES: 2,
            FULL_PAGES: 5,

            // Top 5 networks by volume
            INITIAL_NETWORKS: ['eth', 'arbitrum', 'base', 'polygon_pos', 'optimism'],

            NETWORKS: {
                'L1 Chains': [
                    { id: 'eth', name: 'Ethereum' },
                    { id: 'bsc', name: 'BSC' },
                    { id: 'avax', name: 'Avalanche' }
                ],
                'L2 & Rollups': [
                    { id: 'arbitrum', name: 'Arbitrum' },
                    { id: 'base', name: 'Base' },
                    { id: 'optimism', name: 'Optimism' },
                    { id: 'polygon_pos', name: 'Polygon' },
                    { id: 'zksync', name: 'zkSync' },
                    { id: 'linea', name: 'Linea' },
                    { id: 'scroll', name: 'Scroll' },
                    { id: 'blast', name: 'Blast' }
                ],
                'Other': [
                    { id: 'mantle', name: 'Mantle' },
                    { id: 'gnosis', name: 'Gnosis' }
                ]
            },

            NETWORK_NAMES: {
                eth: 'Ethereum', arbitrum: 'Arbitrum', optimism: 'Optimism', base: 'Base',
                polygon_pos: 'Polygon', zksync: 'zkSync', linea: 'Linea', bsc: 'BSC',
                avax: 'Avalanche', gnosis: 'Gnosis', mantle: 'Mantle', scroll: 'Scroll', blast: 'Blast'
            },

            EXPLORERS: {
                eth: 'https://etherscan.io/address/',
                arbitrum: 'https://arbiscan.io/address/',
                optimism: 'https://optimistic.etherscan.io/address/',
                base: 'https://basescan.org/address/',
                polygon_pos: 'https://polygonscan.com/address/',
                zksync: 'https://explorer.zksync.io/address/',
                linea: 'https://lineascan.build/address/',
                bsc: 'https://bscscan.com/address/',
                avax: 'https://snowtrace.io/address/',
                gnosis: 'https://gnosisscan.io/address/',
                mantle: 'https://explorer.mantle.xyz/address/',
                scroll: 'https://scrollscan.com/address/',
                blast: 'https://blastscan.io/address/'
            },

            // BTC-focused searches
            SEARCHES: [
                'WBTC USDC', 'WBTC USDT', 'WBTC WETH', 'WBTC ETH', 'WBTC DAI',
                'cbBTC USDC', 'cbBTC USDT', 'cbBTC WETH', 'cbBTC ETH',
                'tBTC USDC', 'tBTC WETH', 'WBTC cbBTC', 'WBTC tBTC',
                'BTC USDC', 'BTC USDT', 'BTC ETH'
            ],

            TIMEFRAMES: {
                '24h': { days: 1 },
                '7d': { days: 7 },
                '30d': { days: 30 }
            },

            // BTC variants
            BTC_TOKENS: new Set([
                'btc', 'wbtc', 'cbbtc', 'tbtc', 'renbtc', 'sbtc', 'hbtc', 'btcb',
                'fbtc', 'lbtc', 'solvbtc', 'unibtc', 'pumpbtc', 'ebtc', 'mbtc'
            ]),

            // ETH variants
            ETH_TOKENS: new Set([
                'eth', 'weth', 'steth', 'wsteth', 'reth', 'cbeth', 'meth', 'frxeth', 'weeth', 'ezeth'
            ]),

            // Stablecoins
            STABLE_TOKENS: new Set([
                'usdc', 'usdt', 'dai', 'usdbc', 'frax', 'lusd', 'usds', 'crvusd',
                'tusd', 'busd', 'gusd', 'gho', 'pyusd', 'usde', 'fdusd'
            ]),

            // Excluded tokens
            EXCLUDED: new Set([
                'btcbull', 'btcbear', 'btc2x', 'btc3x', 'btcup', 'btcdown', 'btcpay'
            ])
        };

        // ============================================
        // STATE
        // ============================================
        const state = {
            pools: new Map(),
            loadedNetworks: new Set(),
            selectedNetworks: [...CONFIG.INITIAL_NETWORKS],
            pendingNetworks: [...CONFIG.INITIAL_NETWORKS],
            isLoading: false,
            isFullLoad: false,
            timeframe: '24h',
            sortField: 'utilization',
            sortDir: 'desc',
            ohlcvCache: {},
            lastApiCall: 0
        };

        // ============================================
        // UTILITIES
        // ============================================
        const sleep = ms => new Promise(r => setTimeout(r, ms));

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str || '';
            return div.innerHTML;
        }

        function formatUsd(val) {
            if (val >= 1e9) return '$' + (val / 1e9).toFixed(2) + 'B';
            if (val >= 1e6) return '$' + (val / 1e6).toFixed(2) + 'M';
            if (val >= 1e3) return '$' + (val / 1e3).toFixed(1) + 'K';
            return '$' + val.toFixed(0);
        }

        function formatPercent(val) {
            const pct = val * 100;
            if (pct >= 100) return pct.toFixed(0) + '%';
            if (pct >= 10) return pct.toFixed(1) + '%';
            return pct.toFixed(2) + '%';
        }

        function normalize(sym) {
            return sym ? sym.toLowerCase().replace(/\./g, '').trim() : '';
        }

        // ============================================
        // UI UPDATES
        // ============================================
        function updateStatus(msg, loading = false) {
            const el = document.getElementById('header-status');
            if (loading) {
                el.innerHTML = `<span class="loading-indicator"><span class="spinner spinner-sm"></span> ${escapeHtml(msg)}</span>`;
            } else {
                const count = state.pools.size;
                const nets = state.loadedNetworks.size;
                el.innerHTML = `<span class="pool-count">${count}</span> pools from <span class="network-count">${nets}</span> networks`;
            }
        }

        function setOverlay(active, msg = 'Loading...') {
            const overlay = document.getElementById('panel-overlay');
            document.getElementById('overlay-text').textContent = msg;
            overlay.classList.toggle('active', active);
        }

        function updateLoadStatus() {
            const container = document.getElementById('load-status');
            if (state.isFullLoad) {
                container.innerHTML = `<span class="status-badge full">Full Data</span>`;
            } else {
                container.innerHTML = `
                    <span class="status-badge quick">Quick Load</span>
                    <button class="load-more-btn" id="load-full-btn">Load All Pools</button>
                `;
                document.getElementById('load-full-btn').addEventListener('click', loadFullData);
            }
        }

        // ============================================
        // TOKEN FORMATTING
        // ============================================
        function formatToken(symbol) {
            if (!symbol) return '';
            const upper = symbol.toUpperCase();
            const lower = normalize(symbol);

            if (CONFIG.BTC_TOKENS.has(lower) || lower.includes('btc')) {
                const idx = upper.indexOf('BTC');
                if (idx !== -1) {
                    const prefix = symbol.substring(0, idx).toLowerCase();
                    const suffix = symbol.substring(idx + 3).toLowerCase();
                    let html = prefix ? `<span class="token-prefix">${escapeHtml(prefix)}</span>` : '';
                    html += `<span class="token-btc">BTC</span>`;
                    html += suffix ? `<span class="token-prefix">${escapeHtml(suffix)}</span>` : '';
                    return html;
                }
            }

            if (CONFIG.ETH_TOKENS.has(lower) || lower.includes('eth')) {
                const idx = upper.indexOf('ETH');
                if (idx !== -1) {
                    const prefix = symbol.substring(0, idx).toLowerCase();
                    const suffix = symbol.substring(idx + 3).toLowerCase();
                    let html = prefix ? `<span class="token-prefix">${escapeHtml(prefix)}</span>` : '';
                    html += `<span class="token-eth">ETH</span>`;
                    html += suffix ? `<span class="token-prefix">${escapeHtml(suffix)}</span>` : '';
                    return html;
                }
            }

            if (lower === 'usdc' || lower === 'usdce') return `<span class="token-usdc">${upper}</span>`;
            if (lower === 'usdt') return `<span class="token-usdt">${upper}</span>`;
            if (lower === 'dai') return `<span class="token-dai">${upper}</span>`;
            if (CONFIG.STABLE_TOKENS.has(lower)) return `<span class="token-stable">${upper}</span>`;

            return escapeHtml(upper);
        }

        function formatPoolName(name) {
            if (!name) return '';
            return name.split(/(\s*[\/\-]\s*)/).map(part => {
                if (/^^[\/\-\s]+$/.test(part)) return escapeHtml(part);
                if (/^^\d+\.?\d*%?$/.test(part.trim())) return `<span style="opacity:0.6">${escapeHtml(part)}</span>`;
                return formatToken(part.trim());
            }).join('');
        }

        // ============================================
        // API CLIENT
        // ============================================
        async function apiCall(endpoint, params = {}) {
            const elapsed = Date.now() - state.lastApiCall;
            if (elapsed < CONFIG.RATE_LIMIT_MS) {
                await sleep(CONFIG.RATE_LIMIT_MS - elapsed);
            }
            state.lastApiCall = Date.now();

            const url = new URL(CONFIG.API_BASE + endpoint);
            Object.entries(params).forEach(([k, v]) => {
                if (v != null) url.searchParams.set(k, String(v));
            });

            for (let i = 1; i <= CONFIG.MAX_RETRIES; i++) {
                try {
                    const ctrl = new AbortController();
                    const timeout = setTimeout(() => ctrl.abort(), CONFIG.TIMEOUT_MS);
                    const res = await fetch(url.toString(), {
                        signal: ctrl.signal,
                        headers: { Accept: 'application/json' }
                    });
                    clearTimeout(timeout);

                    if (res.status === 429) {
                        console.warn('Rate limited, waiting...');
                        await sleep(10000);
                        continue;
                    }
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    return await res.json();
                } catch (err) {
                    console.warn(`API error (${i}/${CONFIG.MAX_RETRIES}):`, err.message);
                    if (i < CONFIG.MAX_RETRIES) await sleep(2000 * i);
                }
            }
            return null;
        }

        async function fetchPools(network, page = 1) {
            return await apiCall(`/networks/${network}/pools`, {
                page,
                include: 'dex,base_token,quote_token'
            });
        }

        async function searchPools(query, network) {
            const res = await apiCall('/search/pools', { query, network });
            return res?.data || [];
        }

        async function fetchOHLCV(network, address, days) {
            const res = await apiCall(`/networks/${network}/pools/${address}/ohlcv/day`, {
                aggregate: 1,
                limit: Math.min(days, 365),
                currency: 'usd'
            });
            if (!res) return null;
            const list = res.data?.attributes?.ohlcv_list || [];
            return list.reduce((sum, c) => sum + (parseFloat(c?.[5]) || 0), 0) || null;
        }

        // ============================================
        // POOL PROCESSING
        // ============================================
        function getTokenClass(sym) {
            const n = normalize(sym);
            if (CONFIG.EXCLUDED.has(n)) return null;
            if (CONFIG.BTC_TOKENS.has(n) || n.includes('btc')) return 'BTC';
            if (CONFIG.ETH_TOKENS.has(n) || n.includes('eth')) return 'ETH';
            if (CONFIG.STABLE_TOKENS.has(n)) return 'STABLE';
            return null;
        }

        function getBtcPairType(baseClass, quoteClass) {
            if (baseClass === 'BTC' && quoteClass === 'BTC') return 'wrapped';
            if (baseClass === 'BTC' && quoteClass === 'STABLE') return 'stable';
            if (baseClass === 'STABLE' && quoteClass === 'BTC') return 'stable';
            if (baseClass === 'BTC' && quoteClass === 'ETH') return 'eth';
            if (baseClass === 'ETH' && quoteClass === 'BTC') return 'eth';
            return null;
        }

        function extractFee(name) {
            if (!name) return null;
            const pct = name.match(/(\d+\.?\d*)\s*%/);
            if (pct) {
                const f = parseFloat(pct[1]);
                if (f > 0 && f < 10) return f;
            }
            const bps = name.match(/(\d+)\s*bps/i);
            if (bps) return parseFloat(bps[1]) / 100;
            return null;
        }

        function processPool(data, included = [], network) {
            if (!data?.attributes) return null;
            const attr = data.attributes;
            const address = attr.address;
            if (!address) return null;

            // Get token info
            const baseRef = data.relationships?.base_token?.data;
            const quoteRef = data.relationships?.quote_token?.data;
            const dexRef = data.relationships?.dex?.data;

            let baseSym = null, quoteSym = null, protocol = 'Unknown';

            if (included.length > 0) {
                const baseToken = included.find(i => i.type === 'token' && i.id === baseRef?.id);
                const quoteToken = included.find(i => i.type === 'token' && i.id === quoteRef?.id);
                const dex = included.find(i => i.type === 'dex' && i.id === dexRef?.id);
                baseSym = baseToken?.attributes?.symbol;
                quoteSym = quoteToken?.attributes?.symbol;
                protocol = dex?.attributes?.name || dexRef?.id || 'Unknown';
            }

            // Fallback: parse from name
            if (!baseSym || !quoteSym) {
                const parts = (attr.name || '').split(/[\s\/\-]+/).filter(p => p && !/^^\d/.test(p));
                baseSym = baseSym || parts[0];
                quoteSym = quoteSym || parts[1];
            }

            if (!baseSym || !quoteSym) return null;

            // Check if it's a BTC pair
            const baseClass = getTokenClass(baseSym);
            const quoteClass = getTokenClass(quoteSym);
            if (baseClass !== 'BTC' && quoteClass !== 'BTC') return null;

            const pairType = getBtcPairType(baseClass, quoteClass);
            if (!pairType) return null;

            const liquidity = parseFloat(attr.reserve_in_usd) || 0;
            const volume24h = parseFloat(attr.volume_usd?.h24) || 0;

            if (liquidity < CONFIG.MIN_LIQUIDITY || volume24h < CONFIG.MIN_VOLUME) return null;

            const fee = extractFee(attr.name) || CONFIG.DEFAULT_FEE;
            let poolName = `${baseSym} / ${quoteSym}`;
            if (fee !== CONFIG.DEFAULT_FEE) poolName += ` ${fee}%`;

            protocol = protocol.replace(/_/g, ' ').split(' ')
                .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');

            return {
                id: `${network}_${address.toLowerCase()}`,
                name: poolName,
                baseSym,
                quoteSym,
                pairType,
                liquidity,
                volume24h,
                volumeData: { '24h': volume24h },
                fee,
                chain: CONFIG.NETWORK_NAMES[network] || network,
                chainId: network,
                protocol,
                address,
                poolUrl: `https://www.geckoterminal.com/${network}/pools/${address}`,
                explorerUrl: CONFIG.EXPLORERS[network] ? CONFIG.EXPLORERS[network] + address : ''
            };
        }

        // ============================================
        // DATA LOADING
        // ============================================
        async function loadNetwork(network, pages, onProgress) {
            const discovered = new Map();
            let step = 0;
            const totalSteps = pages + CONFIG.SEARCHES.length;

            // Fetch pool pages
            for (let page = 1; page <= pages; page++) {
                const res = await fetchPools(network, page);
                if (!res?.data?.length) break;

                res.data.forEach(p => {
                    const pool = processPool(p, res.included || [], network);
                    if (pool && !discovered.has(pool.id) && !state.pools.has(pool.id)) {
                        discovered.set(pool.id, pool);
                    }
                });

                step++;
                onProgress?.((step / totalSteps) * 100);
            }

            // Search queries
            for (const query of CONFIG.SEARCHES) {
                const pools = await searchPools(query, network);
                pools.forEach(p => {
                    const pool = processPool(p, [], network);
                    if (pool && !discovered.has(pool.id) && !state.pools.has(pool.id)) {
                        discovered.set(pool.id, pool);
                    }
                });

                step++;
                onProgress?.((step / totalSteps) * 100);
            }

            state.loadedNetworks.add(network);
            return discovered;
        }

        async function loadNetworks(networks, pages) {
            const all = new Map();
            let done = 0;

            for (const net of networks) {
                if (state.loadedNetworks.has(net) && pages === CONFIG.QUICK_PAGES) continue;

                setOverlay(true, `Loading ${CONFIG.NETWORK_NAMES[net] || net}... (${done + 1}/${networks.length})`);

                const discovered = await loadNetwork(net, pages, pct => {
                    setOverlay(true, `Loading ${CONFIG.NETWORK_NAMES[net] || net}: ${Math.round(pct)}%`);
                });

                discovered.forEach((p, id) => all.set(id, p));
                done++;
            }

            return all;
        }

        async function loadInitialData() {
            if (state.isLoading) return;
            state.isLoading = true;

            document.getElementById('refresh-btn').disabled = true;
            state.pools.clear();
            state.loadedNetworks.clear();
            state.ohlcvCache = {};
            state.isFullLoad = false;
            state.timeframe = '24h';
            state.selectedNetworks = [...CONFIG.INITIAL_NETWORKS];

            setOverlay(true, 'Loading BTC pools...');
            updateStatus('Loading...', true);

            try {
                const discovered = await loadNetworks(CONFIG.INITIAL_NETWORKS, CONFIG.QUICK_PAGES);
                discovered.forEach((p, id) => state.pools.set(id, p));

                renderTable();
                updateStatus();
                updateLoadStatus();
                updateNetworkBadge();
                document.getElementById('last-updated').textContent = `Updated: ${new Date().toLocaleTimeString()}`;
            } catch (err) {
                console.error('Load error:', err);
                updateStatus('Error loading data');
            } finally {
                state.isLoading = false;
                document.getElementById('refresh-btn').disabled = false;
                setOverlay(false);
            }
        }

        async function loadFullData() {
            if (state.isLoading || state.isFullLoad) return;
            state.isLoading = true;

            const btn = document.getElementById('load-full-btn');
            if (btn) btn.disabled = true;

            setOverlay(true, 'Loading all BTC pools...');
            updateStatus('Loading full data...', true);

            try {
                // Clear and reload with full pages
                const networks = [...state.selectedNetworks];
                state.loadedNetworks.clear();

                const discovered = await loadNetworks(networks, CONFIG.FULL_PAGES);
                discovered.forEach((p, id) => state.pools.set(id, p));

                state.isFullLoad = true;
                renderTable();
                updateStatus();
                updateLoadStatus();
            } catch (err) {
                console.error('Full load error:', err);
            } finally {
                state.isLoading = false;
                setOverlay(false);
            }
        }

        // ============================================
        // OHLCV FETCHING
        // ============================================
        async function fetchTimeframeData(timeframe) {
            if (timeframe === '24h') return;

            const days = CONFIG.TIMEFRAMES[timeframe].days;
            const pools = getFilteredPools();
            const toFetch = pools.filter(p => {
                const key = `${p.id}_${timeframe}`;
                return state.ohlcvCache[key] === undefined;
            });

            if (toFetch.length === 0) return;

            let done = 0;
            for (const pool of toFetch) {
                setOverlay(true, `Fetching ${days}d volume: ${done + 1}/${toFetch.length}`);

                const vol = await fetchOHLCV(pool.chainId, pool.address, days);
                const key = `${pool.id}_${timeframe}`;
                state.ohlcvCache[key] = vol;

                const cached = state.pools.get(pool.id);
                if (cached) cached.volumeData[timeframe] = vol;

                done++;
            }
        }

        // ============================================
        // FILTERING & METRICS
        // ============================================
        function getFilteredPools() {
            const pools = [];
            state.pools.forEach(p => {
                if (!state.selectedNetworks.includes(p.chainId)) return;
                pools.push({ ...p });
            });
            return pools;
        }

        function calculateMetrics(pool, timeframe) {
            const days = CONFIG.TIMEFRAMES[timeframe].days;
            const vol = pool.volumeData[timeframe];

            if (vol == null || vol <= 0) {
                pool.displayVolume = null;
                pool.utilization = null;
                pool.hasData = false;
            } else {
                pool.displayVolume = vol;
                pool.hasData = true;
                pool.utilization = pool.liquidity > 0 ? (vol / days) / pool.liquidity : 0;
            }

            // APR always from 24h
            const vol24 = pool.volumeData['24h'] || pool.volume24h || 0;
            pool.apr = pool.liquidity > 0 && vol24 > 0
                ? (vol24 * (pool.fee / 100) * 365 / pool.liquidity) * 100
                : null;

            return pool;
        }

        function sortPools(pools, field, dir) {
            return pools.sort((a, b) => {
                let av = a[field], bv = b[field];
                if (typeof av === 'string') av = av.toLowerCase();
                if (typeof bv === 'string') bv = bv.toLowerCase();
                if (av == null) av = dir === 'asc' ? Infinity : -Infinity;
                if (bv == null) bv = dir === 'asc' ? Infinity : -Infinity;
                return dir === 'asc' ? (av > bv ? 1 : -1) : (av < bv ? 1 : -1);
            });
        }

        // ============================================
        // RENDERING
        // ============================================
        function getUtilClass(u) {
            if (u == null) return '';
            const p = u * 100;
            if (p >= 50) return 'utilization-excellent';
            if (p >= 20) return 'utilization-high';
            if (p >= 5) return 'utilization-moderate';
            return 'utilization-low';
        }

        function getAprClass(apr) {
            if (apr == null) return '';
            if (apr >= 50) return 'apr-excellent';
            if (apr >= 20) return 'apr-good';
            if (apr >= 5) return 'apr-moderate';
            return 'apr-low';
        }

        function getFeeClass(fee) {
            if (fee <= 0.05) return 'fee-low';
            if (fee <= 0.3) return 'fee-medium';
            return 'fee-high';
        }

        function getTypeLabel(type) {
            switch (type) {
                case 'stable': return '<span class="type-badge stable">Stable</span>';
                case 'eth': return '<span class="type-badge eth">ETH</span>';
                case 'wrapped': return '<span class="type-badge wrapped">Wrapped</span>';
                default: return '';
            }
        }

        function renderRow(pool, tf) {
            const liqPct = Math.min(100, Math.max(0,
                (Math.log10(Math.max(pool.liquidity, CONFIG.MIN_LIQUIDITY)) - Math.log10(CONFIG.MIN_LIQUIDITY)) /
                (Math.log10(500000000) - Math.log10(CONFIG.MIN_LIQUIDITY)) * 100
            ));

            const tfInd = tf !== '24h' ? `<span class="tf-indicator">(${tf})</span>` : '';
            const volDisplay = pool.displayVolume != null ? formatUsd(pool.displayVolume) : 'N/A';
            const utilDisplay = pool.utilization != null ? formatPercent(pool.utilization) : 'N/A';
            const aprDisplay = pool.apr != null ? pool.apr.toFixed(1) + '%' : 'N/A';

            return `
                <tr>
                    <td class="col-chain">${escapeHtml(pool.chain)}</td>
                    <td class="col-protocol"><span class="protocol-badge">${escapeHtml(pool.protocol)}</span></td>
                    <td class="col-type">${getTypeLabel(pool.pairType)}</td>
                    <td class="col-pool">
                        <div class="pool-cell">
                            <a href="${escapeHtml(pool.poolUrl)}" target="_blank" class="pool-link">${formatPoolName(pool.name)}</a>
                            ${pool.explorerUrl ? `<a href="${escapeHtml(pool.explorerUrl)}" target="_blank" class="explorer-link" title="View contract">📋</a>` : ''}
                        </div>
                    </td>
                    <td class="col-fee"><span class="fee-badge ${getFeeClass(pool.fee)}">${pool.fee.toFixed(2)}%</span></td>
                    <td class="col-liquidity liquidity-cell">
                        <div class="liquidity-bar" style="width:${liqPct}%"></div>
                        <span class="liquidity-value">${formatUsd(pool.liquidity)}</span>
                    </td>
                    <td class="col-volume">${volDisplay}${tfInd}</td>
                    <td class="col-util utilization-value ${getUtilClass(pool.utilization)}">${utilDisplay}</td>
                    <td class="col-apr apr-value ${getAprClass(pool.apr)}">${aprDisplay}</td>
                </tr>
            `;
        }

        function renderTable() {
            let pools = getFilteredPools().map(p => calculateMetrics(p, state.timeframe));

            if (state.timeframe !== '24h') {
                pools = pools.filter(p => p.hasData);
            }

            const sorted = sortPools(pools, state.sortField, state.sortDir);

            const tbody = document.getElementById('pool-tbody');
            const noData = document.getElementById('no-data');
            const count = document.getElementById('pool-count');

            count.textContent = `${sorted.length} pools`;

            if (sorted.length === 0) {
                tbody.innerHTML = '';
                noData.classList.remove('hidden');
            } else {
                tbody.innerHTML = sorted.map(p => renderRow(p, state.timeframe)).join('');
                noData.classList.add('hidden');
            }

            // Update sort indicators
            document.querySelectorAll('th[data-sort]').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                if (th.dataset.sort === state.sortField) {
                    th.classList.add(`sort-${state.sortDir}`);
                }
            });
        }

        // ============================================
        // NETWORK SELECTOR
        // ============================================
        function buildDropdown() {
            let html = `
                <div class="dropdown-header">
                    <span>Select Networks</span>
                    <button id="select-all-loaded">Select All Loaded</button>
                </div>
                <div class="dropdown-content">
            `;

            Object.entries(CONFIG.NETWORKS).forEach(([group, nets]) => {
                html += `<div class="network-group-label">${group}</div>`;
                nets.forEach(net => {
                    const loaded = state.loadedNetworks.has(net.id);
                    const selected = state.pendingNetworks.includes(net.id);
                    html += `
                        <div class="network-item ${selected ? 'selected' : ''} ${!loaded ? 'not-loaded' : ''}" data-net="${net.id}">
                            <div class="network-checkbox">${selected ? '✓' : ''}</div>
                            <span class="network-name">${net.name}</span>
                            <span class="network-tag ${loaded ? 'loaded' : 'not-loaded'}">${loaded ? 'Loaded' : 'Not loaded'}</span>
                        </div>
                    `;
                });
            });

            const toLoad = state.pendingNetworks.filter(n => !state.loadedNetworks.has(n)).length;

            html += `
                </div>
                <div class="dropdown-footer">
                    <div class="dropdown-footer-info">${toLoad > 0 ? `<span class="to-load">${toLoad} to load</span>` : ''}</div>
                    <div class="dropdown-footer-buttons">
                        <button class="btn btn-sm" id="dropdown-cancel">Cancel</button>
                        <button class="btn btn-sm btn-primary" id="dropdown-apply">Apply</button>
                    </div>
                </div>
            `;

            return html;
        }

        function updateNetworkBadge() {
            document.getElementById('network-badge').textContent = state.selectedNetworks.length;
        }

        function openDropdown() {
            const dropdown = document.getElementById('network-dropdown');
            const btn = document.getElementById('network-btn');

            state.pendingNetworks = [...state.selectedNetworks];
            dropdown.innerHTML = buildDropdown();
            dropdown.classList.add('open');
            btn.classList.add('open');

            // Position
            const rect = btn.getBoundingClientRect();
            dropdown.style.top = (rect.bottom + 4) + 'px';
            dropdown.style.right = Math.max(10, window.innerWidth - rect.right) + 'px';

            // Attach listeners
            dropdown.querySelectorAll('.network-item').forEach(item => {
                item.addEventListener('click', () => {
                    const netId = item.dataset.net;
                    const idx = state.pendingNetworks.indexOf(netId);
                    if (idx > -1) {
                        state.pendingNetworks.splice(idx, 1);
                    } else {
                        state.pendingNetworks.push(netId);
                    }
                    dropdown.innerHTML = buildDropdown();
                    attachDropdownListeners();
                });
            });

            attachDropdownListeners();
        }

        function attachDropdownListeners() {
            const dropdown = document.getElementById('network-dropdown');

            dropdown.querySelectorAll('.network-item').forEach(item => {
                item.addEventListener('click', () => {
                    const netId = item.dataset.net;
                    const idx = state.pendingNetworks.indexOf(netId);
                    if (idx > -1) {
                        state.pendingNetworks.splice(idx, 1);
                    } else {
                        state.pendingNetworks.push(netId);
                    }
                    dropdown.innerHTML = buildDropdown();
                    attachDropdownListeners();
                });
            });

            document.getElementById('select-all-loaded')?.addEventListener('click', () => {
                state.pendingNetworks = [...state.loadedNetworks];
                dropdown.innerHTML = buildDropdown();
                attachDropdownListeners();
            });

            document.getElementById('dropdown-cancel')?.addEventListener('click', closeDropdown);

            document.getElementById('dropdown-apply')?.addEventListener('click', async () => {
                const toLoad = state.pendingNetworks.filter(n => !state.loadedNetworks.has(n));
                closeDropdown();

                if (toLoad.length > 0) {
                    state.isLoading = true;
                    setOverlay(true, 'Loading new networks...');
                    updateStatus('Loading...', true);

                    const discovered = await loadNetworks(toLoad, state.isFullLoad ? CONFIG.FULL_PAGES : CONFIG.QUICK_PAGES);
                    discovered.forEach((p, id) => state.pools.set(id, p));

                    state.isLoading = false;
                    setOverlay(false);
                }

                state.selectedNetworks = state.pendingNetworks.filter(n => state.loadedNetworks.has(n));
                renderTable();
                updateStatus();
                updateNetworkBadge();
            });
        }

        function closeDropdown() {
            document.getElementById('network-dropdown').classList.remove('open');
            document.getElementById('network-btn').classList.remove('open');
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================
        function initEventHandlers() {
            // Refresh
            document.getElementById('refresh-btn').addEventListener('click', loadInitialData);

            // Network selector
            document.getElementById('network-btn').addEventListener('click', e => {
                e.stopPropagation();
                const dropdown = document.getElementById('network-dropdown');
                if (dropdown.classList.contains('open')) {
                    closeDropdown();
                } else {
                    openDropdown();
                }
            });

            document.addEventListener('click', closeDropdown);
            document.getElementById('network-dropdown').addEventListener('click', e => e.stopPropagation());

            // Timeframe
            document.querySelectorAll('.tf-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const tf = btn.dataset.tf;
                    if (tf === state.timeframe) return;

                    document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.timeframe = tf;

                    if (tf !== '24h') {
                        setOverlay(true, `Fetching ${CONFIG.TIMEFRAMES[tf].days}d volume...`);
                        await fetchTimeframeData(tf);
                        setOverlay(false);
                    }

                    renderTable();
                });
            });

            // Sorting
            document.querySelectorAll('th[data-sort]').forEach(th => {
                th.addEventListener('click', () => {
                    const field = th.dataset.sort;
                    if (state.sortField === field) {
                        state.sortDir = state.sortDir === 'asc' ? 'desc' : 'asc';
                    } else {
                        state.sortField = field;
                        state.sortDir = 'desc';
                    }
                    renderTable();
                });
            });
        }

        // ============================================
        // INIT
        // ============================================
        function init() {
            initEventHandlers();
            loadInitialData();
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    })();
    </script>
</body>
</html>
