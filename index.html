<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High Utilization LP Dashboard</title>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --bg-color-lighter: #111111;
            --surface-color: #1a1a1a;
            --surface-color-alt: #141414;
            --primary-text-color: #e0e0e0;
            --secondary-text-color: #888888;
            --border-color: #2a2a2a;
            --accent-color: #666666;
            --hover-bg-color: #222222;
            --success-color: #4ade80;
            --warning-color: #fbbf24;
            --error-color: #f87171;
            --btc-color: #f7931a;
            --eth-color: #87CEEB;
            --usdc-color: #4A90E2;
            --usdt-color: #5CB85C;
            --dai-color: #D4A76A;
            --apr-low: #1a5f2a;
            --apr-moderate: #2d8a3e;
            --apr-good: #48bb5c;
            --apr-excellent: #4ade80;
            --util-low: #4a3a6b;
            --util-moderate: #7c5dac;
            --util-high: #a78bfa;
            --util-excellent: #c4b5fd;
            --section-bg: #0f0f0f;
            --section-border: #2a2a2a;
            --section-header-bg: #151515;
            --section-th-bg: #121212;
            --link-color: #999999;
            --link-color-hover: #cccccc;
            --liquidity-bar-color: hsl(270, 50%, 35%);
            --geckoterminal-color: #7c3aed;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--primary-text-color);
            line-height: 1.5;
            min-height: 100vh;
        }

        header {
            padding: 1.25rem 2rem;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-color-lighter);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 1rem;
            max-width: 1920px;
            margin: 0 auto;
        }

        .header-left h1 {
            font-size: 1.6rem;
            font-weight: 600;
            color: var(--primary-text-color);
            margin-bottom: 0.4rem;
        }

        .header-left p {
            color: var(--secondary-text-color);
            font-size: 0.9rem;
        }

        .header-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.5rem;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header-status {
            font-size: 0.8rem;
            color: var(--secondary-text-color);
            text-align: right;
        }

        .header-status .pool-count {
            color: var(--success-color);
            font-weight: 600;
        }

        .header-status .network-count {
            color: var(--util-high);
            font-weight: 500;
        }

        .header-status .loading-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--warning-color);
        }

        .header-status .error-indicator {
            color: var(--error-color);
        }

        main {
            padding: 1.25rem;
            max-width: 1920px;
            margin: 0 auto;
        }

        footer {
            padding: 0.75rem 2rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.8rem;
            color: var(--secondary-text-color);
        }

        .data-sources {
            margin-top: 0.5rem;
            font-size: 0.75rem;
        }

        .source-gecko {
            color: var(--geckoterminal-color);
        }

        .btn {
            background-color: #333333;
            color: #fff;
            border: 1px solid #444444;
            padding: 0.5rem 1rem;
            border-radius: 3px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .btn:hover {
            background-color: #444444;
            transform: translateY(-1px);
        }

        .btn:disabled {
            background-color: #222222;
            color: var(--secondary-text-color);
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary {
            background-color: var(--util-moderate);
            border-color: var(--util-high);
        }

        .btn-primary:hover {
            background-color: var(--util-high);
        }

        .btn-sm {
            padding: 0.4rem 0.8rem;
            font-size: 0.8rem;
        }

        #progress-container {
            width: 100%;
            height: 4px;
            background-color: var(--border-color);
            border-radius: 2px;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        #progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--geckoterminal-color), var(--util-excellent));
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid var(--border-color);
            border-top: 2px solid var(--primary-text-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .spinner-sm {
            width: 12px;
            height: 12px;
            border-width: 1.5px;
        }

        .hidden {
            display: none !important;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #dashboard-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.25rem;
            min-height: 500px;
        }

        #stablecoin-section-wrapper {
            margin-top: 1.25rem;
        }

        .pair-section {
            background-color: var(--section-bg);
            border: 1px solid var(--section-border);
            border-radius: 3px;
            display: flex;
            flex-direction: column;
            min-height: 320px;
            max-height: 450px;
            position: relative;
        }

        .pair-section.full-width {
            max-height: 380px;
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background-color: var(--section-header-bg);
            border-bottom: 1px solid var(--section-border);
            flex-shrink: 0;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .section-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.05rem;
            font-weight: 600;
        }

        .pool-count {
            font-size: 0.85rem;
            font-weight: 400;
            opacity: 0.7;
        }

        .section-controls {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            flex-wrap: wrap;
        }

        .timeframe-toggle {
            display: flex;
            align-items: center;
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 2px;
            gap: 2px;
        }

        .tf-btn {
            background-color: transparent;
            color: var(--secondary-text-color);
            border: none;
            padding: 0.3rem 0.55rem;
            border-radius: 2px;
            font-size: 0.72rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
        }

        .tf-btn:hover {
            background-color: var(--hover-bg-color);
            color: var(--primary-text-color);
        }

        .tf-btn.active {
            background-color: var(--util-moderate);
            color: #fff;
        }

        .network-selector {
            position: relative;
        }

        .network-btn {
            background-color: var(--surface-color);
            color: var(--secondary-text-color);
            border: 1px solid var(--border-color);
            padding: 0.35rem 0.65rem;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .network-btn:hover {
            background-color: var(--hover-bg-color);
            color: var(--primary-text-color);
            border-color: #444;
        }

        .network-btn.open {
            border-color: var(--util-moderate);
        }

        .network-badge {
            background-color: var(--util-moderate);
            color: #fff;
            font-size: 0.65rem;
            padding: 0.1rem 0.35rem;
            border-radius: 2px;
            font-weight: 600;
        }

        .network-arrow {
            font-size: 0.55rem;
            transition: transform 0.2s ease;
        }

        .network-btn.open .network-arrow {
            transform: rotate(180deg);
        }

        .network-dropdown {
            position: fixed;
            width: 320px;
            max-width: calc(100vw - 20px);
            max-height: 600px;
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            z-index: 9999;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
        }

        .network-dropdown.open {
            display: flex;
        }

        .dropdown-header {
            padding: 0.6rem 0.75rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.7rem;
            color: var(--secondary-text-color);
            text-transform: uppercase;
            letter-spacing: 0.03em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .dropdown-header button {
            background: none;
            border: none;
            color: var(--util-high);
            font-size: 0.7rem;
            cursor: pointer;
            padding: 0;
        }

        .dropdown-header button:hover {
            text-decoration: underline;
        }

        .dropdown-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.4rem 0;
        }

        .network-group-label {
            font-size: 0.65rem;
            color: var(--secondary-text-color);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.5rem 0.75rem 0.25rem;
            opacity: 0.7;
        }

        .network-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.75rem;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }

        .network-item:hover {
            background-color: var(--hover-bg-color);
        }

        .network-item.selected {
            background-color: rgba(167, 139, 250, 0.1);
        }

        .network-item.not-loaded {
            opacity: 0.5;
        }

        .network-item.not-loaded:hover {
            background-color: rgba(251, 191, 36, 0.1);
            opacity: 0.7;
        }

        .network-item.not-loaded.selected {
            background-color: rgba(251, 191, 36, 0.15);
            opacity: 0.8;
        }

        .network-checkbox {
            width: 14px;
            height: 14px;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            color: #fff;
            background-color: var(--bg-color);
            flex-shrink: 0;
        }

        .network-item.selected .network-checkbox {
            background-color: var(--util-moderate);
            border-color: var(--util-high);
        }

        .network-item.not-loaded.selected .network-checkbox {
            background-color: var(--warning-color);
            border-color: var(--warning-color);
        }

        .network-name {
            font-size: 0.8rem;
            color: var(--primary-text-color);
            flex: 1;
        }

        .network-tag {
            font-size: 0.6rem;
            color: var(--util-high);
            background-color: rgba(167, 139, 250, 0.15);
            padding: 0.1rem 0.3rem;
            border-radius: 2px;
        }

        .not-loaded-tag {
            font-size: 0.6rem;
            color: var(--warning-color);
            background-color: rgba(251, 191, 36, 0.15);
            padding: 0.1rem 0.3rem;
            border-radius: 2px;
        }

        .loaded-tag {
            font-size: 0.6rem;
            color: var(--success-color);
            background-color: rgba(74, 222, 128, 0.15);
            padding: 0.1rem 0.3rem;
            border-radius: 2px;
        }

        .dropdown-footer {
            padding: 0.6rem 0.75rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            gap: 0.5rem;
        }

        .dropdown-footer-info {
            font-size: 0.7rem;
            color: var(--secondary-text-color);
        }

        .dropdown-footer-info .to-load {
            color: var(--warning-color);
            font-weight: 600;
        }

        .dropdown-footer-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .dropdown-footer .btn {
            padding: 0.35rem 0.75rem;
            font-size: 0.75rem;
        }

        .section-overlay {
            position: absolute;
            inset: 0;
            background-color: rgba(10, 10, 10, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
        }

        .section-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .section-overlay .spinner {
            width: 28px;
            height: 28px;
            border-width: 3px;
            border-top-color: var(--util-high);
            margin-bottom: 0.75rem;
        }

        .section-overlay-text {
            font-size: 0.85rem;
            color: var(--secondary-text-color);
            text-align: center;
            padding: 0 1rem;
        }

        .section-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .table-container {
            flex: 1;
            overflow: auto;
            min-height: 0;
        }

        .pool-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            table-layout: fixed;
        }

        .pool-table th,
        .pool-table td {
            padding: 0.55rem 0.7rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            white-space: nowrap;
            vertical-align: middle;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .pool-table .col-chain { width: 80px; }
        .pool-table .col-protocol { width: 90px; }
        .pool-table .col-pool { width: 200px; min-width: 180px; }
        .pool-table .col-fee { width: 65px; }
        .pool-table .col-liquidity { width: 100px; }
        .pool-table .col-volume { width: 110px; }
        .pool-table .col-util { width: 80px; }
        .pool-table .col-apr { width: 90px; }

        .pool-table .col-liquidity,
        .pool-table .col-volume,
        .pool-table .col-util,
        .pool-table .col-apr,
        .pool-table td:nth-child(5),
        .pool-table td:nth-child(6),
        .pool-table td:nth-child(7),
        .pool-table td:nth-child(8) {
            text-align: right;
        }

        .pool-table th {
            background-color: var(--section-th-bg);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
            font-size: 0.73rem;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            color: var(--secondary-text-color);
        }

        .pool-table th:hover {
            color: var(--primary-text-color);
        }

        .pool-table th[data-sort]::after {
            content: ' ⇅';
            opacity: 0.4;
            font-size: 0.65em;
        }

        .pool-table th.sort-asc::after {
            content: ' ↑';
            opacity: 1;
        }

        .pool-table th.sort-desc::after {
            content: ' ↓';
            opacity: 1;
        }

        .pool-table tbody tr {
            transition: background-color 0.15s ease;
        }

        .pool-table tbody tr:hover {
            background-color: var(--hover-bg-color);
        }

        .pool-table tbody tr:last-child td {
            border-bottom: none;
        }

        .pool-link, .explorer-link {
            color: var(--link-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.15s ease;
        }

        .pool-link:hover, .explorer-link:hover {
            color: var(--link-color-hover);
            text-decoration: underline;
        }

        .pool-cell {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            min-width: 180px;
        }

        .pool-cell .pool-link {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .pool-cell .explorer-link {
            flex-shrink: 0;
            width: 18px;
            text-align: center;
            font-size: 0.75rem;
            opacity: 0.5;
        }

        .pool-cell .explorer-link:hover {
            opacity: 1;
        }

        .token-btc { color: var(--btc-color); font-weight: 600; }
        .token-eth { color: var(--eth-color); font-weight: 600; }
        .token-usdc { color: var(--usdc-color); font-weight: 600; }
        .token-usdt { color: var(--usdt-color); font-weight: 600; }
        .token-dai { color: var(--dai-color); font-weight: 600; }
        .token-stable { color: var(--primary-text-color); font-weight: 500; }
        .token-prefix { font-weight: 400; }

        .protocol-badge {
            display: inline-block;
            padding: 0.1rem 0.35rem;
            border-radius: 2px;
            font-size: 0.7rem;
            font-weight: 500;
            background-color: rgba(255, 255, 255, 0.08);
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .fee-badge {
            display: inline-block;
            padding: 0.12rem 0.35rem;
            border-radius: 2px;
            font-size: 0.75rem;
            font-weight: 600;
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--secondary-text-color);
        }

        .fee-badge.fee-low {
            background-color: rgba(74, 222, 128, 0.2);
            color: var(--success-color);
        }

        .fee-badge.fee-medium {
            background-color: rgba(251, 191, 36, 0.2);
            color: var(--warning-color);
        }

        .fee-badge.fee-high {
            background-color: rgba(248, 113, 113, 0.2);
            color: var(--error-color);
        }

        .liquidity-cell {
            position: relative;
            font-weight: 500;
        }

        .liquidity-bar {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            opacity: 0.4;
            border-radius: 1px;
            z-index: 0;
            background: linear-gradient(90deg, hsl(270, 50%, 25%), hsl(270, 50%, 40%));
        }

        .liquidity-value {
            position: relative;
            z-index: 1;
        }

        .apr-value { font-weight: 600; }
        .apr-excellent { color: var(--apr-excellent); }
        .apr-good { color: var(--apr-good); }
        .apr-moderate { color: var(--apr-moderate); }
        .apr-low { color: var(--apr-low); }

        .utilization-value { font-weight: 600; }
        .utilization-excellent { color: var(--util-excellent); }
        .utilization-high { color: var(--util-high); }
        .utilization-moderate { color: var(--util-moderate); }
        .utilization-low { color: var(--util-low); }

        .no-data {
            text-align: center;
            padding: 2.5rem 1rem;
            color: var(--secondary-text-color);
            font-size: 0.9rem;
        }

        .tf-indicator {
            font-size: 0.65rem;
            opacity: 0.6;
            margin-left: 0.2rem;
            display: inline-block;
            min-width: 28px;
        }

        .volume-cell, .apr-cell {
            white-space: nowrap;
        }

        .table-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .table-container::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        .table-container::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .table-container::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-text-color);
        }

        #debug-section {
            margin-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            padding-top: 1rem;
        }

        .debug-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .debug-toggle {
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            color: var(--secondary-text-color);
            padding: 0.3rem 0.6rem;
            border-radius: 2px;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .debug-toggle:hover {
            background-color: var(--hover-bg-color);
            color: var(--primary-text-color);
        }

        #debug-log {
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 1rem;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 0.72rem;
            max-height: 280px;
            overflow-y: auto;
            line-height: 1.5;
        }

        .log-error { color: var(--error-color); }
        .log-warn { color: var(--warning-color); }
        .log-success { color: var(--success-color); }
        .log-info { color: var(--secondary-text-color); }
        .log-gecko { color: var(--geckoterminal-color); }

        @media (max-width: 1200px) {
            #dashboard-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            header {
                padding: 1rem;
            }

            .header-content {
                flex-direction: column;
                align-items: flex-start;
            }

            .header-right {
                align-items: flex-start;
                width: 100%;
            }

            .header-left h1 {
                font-size: 1.3rem;
            }

            main {
                padding: 0.75rem;
            }

            .section-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .section-controls {
                width: 100%;
                justify-content: space-between;
            }

            .pair-section {
                min-height: 280px;
                max-height: 400px;
            }

            .pool-table th,
            .pool-table td {
                padding: 0.45rem 0.5rem;
                font-size: 0.78rem;
            }

            .pool-table .col-pool {
                min-width: 150px;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="header-left">
                <h1>High Utilization LP Dashboard</h1>
                <p>Find heavily utilized LPs via GeckoTerminal. Ranks pools by Utilization % (Volume ÷ Liquidity × 100). APR estimated from volume × fee.</p>
            </div>
            <div class="header-right">
                <div class="header-controls">
                    <div class="header-status" id="header-status">
                        <span class="loading-indicator">
                            <span class="spinner spinner-sm"></span>
                            Initializing...
                        </span>
                    </div>
                    <button id="refresh-btn" class="btn btn-sm">Refresh Data</button>
                </div>
                <div id="last-updated" style="font-size: 0.75rem; color: var(--secondary-text-color);"></div>
            </div>
        </div>
    </header>

    <main>
        <div id="progress-container" class="hidden">
            <div id="progress-bar"></div>
        </div>

        <div id="dashboard-grid"></div>
        <div id="stablecoin-section-wrapper"></div>

        <div id="debug-section" class="hidden">
            <div class="debug-header">
                <span style="font-size: 0.75rem; color: var(--secondary-text-color);">Debug Log</span>
                <button id="clear-debug" class="debug-toggle">Clear</button>
            </div>
            <div id="debug-log"></div>
        </div>
    </main>

    <footer>
        <p>
            Always DYOR.
            <button id="debug-toggle" class="debug-toggle" style="margin-left: 1rem;">Toggle Debug</button>
        </p>
        <div class="data-sources">
            <span class="source-gecko">● Powered by GeckoTerminal API — Real volume & historical OHLCV data</span>
        </div>
    </footer>

    <script>
    (function() {
        'use strict';

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            GECKOTERMINAL_API: 'https://api.geckoterminal.com/api/v2',
            RATE_LIMIT_MS: 2200,
            MAX_RETRIES: 3,
            RETRY_DELAY_MS: 2000,
            TIMEOUT_MS: 25000,
            MIN_LIQUIDITY: 50000,
            MIN_VOLUME_24H: 1000,
            DEFAULT_FEE: 0.3,
            POOLS_PER_PAGE: 20,
            MAX_PAGES_PER_NETWORK: 5,

            INITIAL_NETWORKS: ['eth', 'arbitrum', 'base'],

            NETWORK_GROUPS: {
                'L1 Networks': [
                    { id: 'eth', name: 'Ethereum', initial: true },
                    { id: 'bsc', name: 'BSC' },
                    { id: 'avax', name: 'Avalanche' },
                    { id: 'fantom', name: 'Fantom' },
                    { id: 'gnosis', name: 'Gnosis' }
                ],
                'Ethereum L2s': [
                    { id: 'arbitrum', name: 'Arbitrum', initial: true },
                    { id: 'base', name: 'Base', initial: true },
                    { id: 'optimism', name: 'Optimism' },
                    { id: 'zksync', name: 'zkSync' },
                    { id: 'linea', name: 'Linea' },
                    { id: 'mode', name: 'Mode' },
                    { id: 'manta', name: 'Manta' },
                    { id: 'scroll', name: 'Scroll' },
                    { id: 'blast', name: 'Blast' }
                ],
                'Other': [
                    { id: 'polygon_pos', name: 'Polygon' },
                    { id: 'mantle', name: 'Mantle' },
                    { id: 'celo', name: 'Celo' }
                ],
                'Non-EVM': [
                    { id: 'solana', name: 'Solana' },
                    { id: 'sui', name: 'Sui' }
                ]
            },

            NETWORK_NAMES: {
                eth: 'Ethereum',
                arbitrum: 'Arbitrum',
                optimism: 'Optimism',
                base: 'Base',
                polygon_pos: 'Polygon',
                zksync: 'zkSync',
                linea: 'Linea',
                bsc: 'BSC',
                avax: 'Avalanche',
                fantom: 'Fantom',
                gnosis: 'Gnosis',
                mode: 'Mode',
                mantle: 'Mantle',
                manta: 'Manta',
                scroll: 'Scroll',
                blast: 'Blast',
                celo: 'Celo',
                solana: 'Solana',
                sui: 'Sui'
            },

            EXPLORERS: {
                eth: 'https://etherscan.io/address/',
                arbitrum: 'https://arbiscan.io/address/',
                optimism: 'https://optimistic.etherscan.io/address/',
                base: 'https://basescan.org/address/',
                polygon_pos: 'https://polygonscan.com/address/',
                zksync: 'https://explorer.zksync.io/address/',
                linea: 'https://lineascan.build/address/',
                bsc: 'https://bscscan.com/address/',
                avax: 'https://snowtrace.io/address/',
                fantom: 'https://ftmscan.com/address/',
                gnosis: 'https://gnosisscan.io/address/',
                mode: 'https://explorer.mode.network/address/',
                mantle: 'https://explorer.mantle.xyz/address/',
                manta: 'https://pacific-explorer.manta.network/address/',
                scroll: 'https://scrollscan.com/address/',
                blast: 'https://blastscan.io/address/',
                solana: 'https://solscan.io/account/',
                sui: 'https://suiscan.xyz/mainnet/object/'
            },

            // Search queries for discovering pools
            SEARCHES: {
                'btc-stable': ['WBTC USDC', 'WBTC USDT', 'cbBTC USDC', 'cbBTC USDT', 'tBTC USDC', 'WBTC DAI', 'BTC USDC', 'BTC USDT'],
                'eth-stable': ['WETH USDC', 'WETH USDT', 'ETH USDC', 'ETH USDT', 'WETH DAI', 'ETH DAI', 'stETH USDC'],
                'btc-eth': ['WBTC WETH', 'WBTC ETH', 'cbBTC WETH', 'cbBTC ETH', 'WBTC cbBTC', 'tBTC WETH'],
                'wrapped': ['wstETH ETH', 'wstETH WETH', 'rETH WETH', 'rETH ETH', 'cbETH WETH', 'cbETH ETH', 'stETH ETH', 'frxETH WETH', 'swETH WETH', 'mETH WETH', 'ezETH WETH', 'weETH WETH', 'rsETH WETH'],
                'stable-stable': ['USDC USDT', 'USDC DAI', 'USDT DAI', 'GHO USDC', 'GHO USDT', 'FRAX USDC', 'LUSD USDC', 'crvUSD USDC', 'USDS USDC', 'USDE USDT']
            },

            TIMEFRAMES: {
                '24h': { days: 1, label: '24h' },
                '7d': { days: 7, label: '7d' },
                '30d': { days: 30, label: '30d' },
                '1y': { days: 365, label: '1y' }
            },

            SECTIONS: [
                { id: 'btc-stable', title: '<span class="token-btc">BTC</span> / Stablecoin', grid: true },
                { id: 'eth-stable', title: '<span class="token-eth">ETH</span> / Stablecoin', grid: true },
                { id: 'btc-eth', title: '<span class="token-btc">BTC</span> / <span class="token-eth">ETH</span>', grid: true },
                { id: 'wrapped', title: 'Wrapped Twins', grid: true },
                { id: 'stable-stable', title: 'Stablecoin Pairs', grid: false }
            ],

            ASSETS: {
                BTC: ['btc', 'wbtc', 'cbbtc', 'tbtc', 'renbtc', 'sbtc', 'hbtc', 'wbtce', 'btcb', 'obtc', 'pbtc', 'ibtc', 'fbtc', 'lbtc', 'kbtc', 'ebtc', 'solvbtc', 'unibtc', 'pumpbtc', 'dlcbtc', 'stbtc', 'mbtc', 'xbtc', 'abtc', 'nbtc', 'dbtc', 'zbtc', 'ubtc', 'hemibtc', 'vbtc', 'yybtc', 'bbtc', 'gbtc', 'qbtc'],
                ETH: ['eth', 'weth', 'steth', 'wsteth', 'reth', 'cbeth', 'wethe', 'ethb', 'seth', 'meth', 'oeth', 'frxeth', 'sfrxeth', 'sweth', 'ankreth', 'eeth', 'weeth', 'ezeth', 'rseth', 'pxeth', 'unieth', 'ethx', 'insteth', 'neth', 'oseth', 'mpeth', 'ineth', 'wbeth', 'rsweth', 'saeth', 'apxeth', 'ueth', 'wheth', 'zeth', 'heth', 'veth', 'aeth', 'deth', 'yeth', 'yyeth', 'geth', 'qeth'],
                STABLE: ['usdc', 'usdt', 'dai', 'usdbc', 'frax', 'lusd', 'usds', 'crvusd', 'tusd', 'busd', 'gusd', 'usdp', 'usdd', 'pyusd', 'eusd', 'gho', 'mkusd', 'dola', 'susd', 'usd+', 'usdb', 'usdm', 'usde', 'usd0', 'fdusd', 'eur', 'eurt', 'eurc', 'ageur', 'ceur', 'usdk', 'usdn', 'mimatic', 'mai', 'alusd', 'mim', 'susdv2', 'susde', 'ousdt', 'ousdc', 'odai', 'wusdc', 'wusdt', 'wdai', 'usdce', 'usdtce', 'daie']
            },

            EXCLUDED: new Set(['btcbull', 'btcbear', 'ethbull', 'ethbear', 'btc2x', 'eth2x', 'btc3x', 'eth3x', 'btcup', 'btcdown', 'ethup', 'ethdown', 'ethfi', 'etherfi', 'btcpay', 'ethpay', 'btcdao', 'ethdao', 'btcix', 'ethix', 'methane', 'methanol', 'ethanol', 'ethernet', 'synthesis', 'synthetic', 'aesthetics', 'bethel', 'beth', 'elizabeth', 'macbeth']),

            STABLE_PAIRS: new Set(['usdc', 'usdt', 'gho', 'dai', 'usdbc', 'frax', 'lusd', 'usde', 'usds', 'crvusd'])
        };

        // Build asset lookup
        const ASSET_MAP = {};
        Object.entries(CONFIG.ASSETS).forEach(([cls, tokens]) => {
            tokens.forEach(t => ASSET_MAP[t.toLowerCase().replace(/\./g, '')] = cls);
        });

        // ============================================
        // STATE
        // ============================================
        const state = {
            pools: new Map(),
            loadedNetworks: new Set(),
            isLoading: false,
            debugLogs: [],
            apiCalls: 0,
            lastApiCall: 0,
            sections: {}
        };

        CONFIG.SECTIONS.forEach(s => {
            state.sections[s.id] = {
                networks: [...CONFIG.INITIAL_NETWORKS],
                pendingNetworks: [...CONFIG.INITIAL_NETWORKS],
                timeframe: '24h',
                ohlcvCache: {},
                sortField: 'utilization',
                sortDir: 'desc'
            };
        });

        // ============================================
        // UTILITIES
        // ============================================
        const sleep = ms => new Promise(r => setTimeout(r, ms));

        function log(msg, type = 'info') {
            const ts = new Date().toLocaleTimeString();
            state.debugLogs.push({ ts, type, msg });
            if (state.debugLogs.length > 500) state.debugLogs = state.debugLogs.slice(-400);
            console.log(`[${ts}] [${type.toUpperCase()}] ${msg}`);
            renderDebugLog();
        }

        function renderDebugLog() {
            const el = document.getElementById('debug-log');
            if (el) {
                el.innerHTML = state.debugLogs.map(l =>
                    `<div class="log-${l.type}">[${l.ts}] ${l.msg}</div>`
                ).join('');
                el.scrollTop = el.scrollHeight;
            }
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str || '';
            return div.innerHTML;
        }

        function formatUsd(val) {
            if (val >= 1e9) return '$' + (val / 1e9).toFixed(2) + 'B';
            if (val >= 1e6) return '$' + (val / 1e6).toFixed(2) + 'M';
            if (val >= 1e3) return '$' + (val / 1e3).toFixed(1) + 'K';
            return '$' + val.toFixed(0);
        }

        function formatUtilization(util) {
            const pct = util * 100;
            if (pct >= 100) return pct.toFixed(0) + '%';
            if (pct >= 10) return pct.toFixed(1) + '%';
            return pct.toFixed(2) + '%';
        }

        function updateHeaderStatus(msg, type = 'info', loading = false) {
            const el = document.getElementById('header-status');
            if (!el) return;

            if (loading) {
                el.innerHTML = `
                    <span class="loading-indicator">
                        <span class="spinner spinner-sm"></span>
                        ${escapeHtml(msg)}
                    </span>
                `;
            } else if (type === 'error') {
                el.innerHTML = `<span class="error-indicator">${escapeHtml(msg)}</span>`;
            } else if (type === 'success') {
                const poolCount = state.pools.size;
                const networkCount = state.loadedNetworks.size;
                el.innerHTML = `
                    <span class="pool-count">${poolCount}</span> pools from 
                    <span class="network-count">${networkCount}</span> networks
                `;
            } else {
                el.innerHTML = escapeHtml(msg);
            }
        }

        function updateProgress(pct) {
            const container = document.getElementById('progress-container');
            const bar = document.getElementById('progress-bar');
            if (pct > 0 && pct < 100) {
                container.classList.remove('hidden');
                bar.style.width = pct + '%';
            } else {
                container.classList.add('hidden');
                bar.style.width = '0%';
            }
        }

        // ============================================
        // TOKEN FORMATTING
        // ============================================
        function formatTokenSymbol(symbol) {
            if (!symbol) return '';
            const original = symbol.trim();
            const upper = original.toUpperCase();
            const lower = original.toLowerCase();

            const btcIndex = upper.indexOf('BTC');
            if (btcIndex !== -1 && !CONFIG.EXCLUDED.has(lower)) {
                const prefix = original.substring(0, btcIndex).toLowerCase();
                const suffix = original.substring(btcIndex + 3).toLowerCase();
                let html = '';
                if (prefix) html += `<span class="token-prefix">${escapeHtml(prefix)}</span>`;
                html += `<span class="token-btc">BTC</span>`;
                if (suffix) html += `<span class="token-prefix">${escapeHtml(suffix)}</span>`;
                return html;
            }

            const ethIndex = upper.indexOf('ETH');
            if (ethIndex !== -1 && !CONFIG.EXCLUDED.has(lower)) {
                const prefix = original.substring(0, ethIndex).toLowerCase();
                const suffix = original.substring(ethIndex + 3).toLowerCase();
                let html = '';
                if (prefix) html += `<span class="token-prefix">${escapeHtml(prefix)}</span>`;
                html += `<span class="token-eth">ETH</span>`;
                if (suffix) html += `<span class="token-prefix">${escapeHtml(suffix)}</span>`;
                return html;
            }

            const normalized = lower.replace(/\./g, '');
            if (normalized === 'usdc' || normalized === 'usdce') {
                return `<span class="token-usdc">${escapeHtml(upper)}</span>`;
            }
            if (normalized === 'usdt' || normalized === 'usdtce' || normalized === 'usdte') {
                return `<span class="token-usdt">${escapeHtml(upper)}</span>`;
            }
            if (normalized === 'dai' || normalized === 'daie') {
                return `<span class="token-dai">${escapeHtml(upper)}</span>`;
            }
            if (ASSET_MAP[normalized] === 'STABLE') {
                return `<span class="token-stable">${escapeHtml(upper)}</span>`;
            }

            return escapeHtml(upper);
        }

        function colorizePoolName(name) {
            if (!name) return '';
            const parts = name.split(/(\s*[\/\-]\s*)/);
            return parts.map(part => {
                const trimmed = part.trim();
                if (/^^[\/\-\s]+$/.test(part)) return escapeHtml(part);
                if (/^^\d+\.?\d*%?$/.test(trimmed)) {
                    return `<span style="opacity:0.6">${escapeHtml(trimmed)}</span>`;
                }
                return formatTokenSymbol(trimmed);
            }).join('');
        }

        // ============================================
        // GECKOTERMINAL API CLIENT
        // ============================================
        async function geckoApiCall(endpoint, params = {}) {
            const now = Date.now();
            const elapsed = now - state.lastApiCall;
            if (elapsed < CONFIG.RATE_LIMIT_MS) {
                await sleep(CONFIG.RATE_LIMIT_MS - elapsed);
            }
            state.lastApiCall = Date.now();
            state.apiCalls++;

            const url = new URL(CONFIG.GECKOTERMINAL_API + endpoint);
            Object.entries(params).forEach(([k, v]) => {
                if (v != null) url.searchParams.set(k, String(v));
            });

            for (let attempt = 1; attempt <= CONFIG.MAX_RETRIES; attempt++) {
                try {
                    const ctrl = new AbortController();
                    const timeout = setTimeout(() => ctrl.abort(), CONFIG.TIMEOUT_MS);
                    const res = await fetch(url.toString(), {
                        signal: ctrl.signal,
                        headers: { Accept: 'application/json' }
                    });
                    clearTimeout(timeout);

                    if (res.status === 429) {
                        log('GeckoTerminal rate limited, waiting 10s...', 'warn');
                        await sleep(10000);
                        continue;
                    }

                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    return await res.json();
                } catch (err) {
                    log(`GeckoTerminal error (${attempt}/${CONFIG.MAX_RETRIES}): ${err.message}`, 'warn');
                    if (attempt < CONFIG.MAX_RETRIES) {
                        await sleep(CONFIG.RETRY_DELAY_MS * attempt);
                    }
                }
            }
            return null;
        }

        async function fetchTopPools(network, page = 1) {
            const res = await geckoApiCall(`/networks/${network}/pools`, {
                page,
                include: 'dex,base_token,quote_token'
            });
            return res;
        }

        async function searchPools(query, network = null) {
            const params = { query };
            if (network) params.network = network;
            const res = await geckoApiCall('/search/pools', params);
            return res?.data || [];
        }

        async function fetchOHLCV(network, address, days) {
            const res = await geckoApiCall(`/networks/${network}/pools/${address}/ohlcv/day`, {
                aggregate: 1,
                limit: Math.min(days, 365),
                currency: 'usd'
            });

            if (!res) return { volume: null };

            const list = res.data?.attributes?.ohlcv_list || [];
            if (list.length === 0) return { volume: null };

            let vol = 0;
            list.forEach(c => {
                if (c && c[5]) vol += parseFloat(c[5]) || 0;
            });
            return { volume: vol > 0 ? vol : null };
        }

        // ============================================
        // POOL PROCESSING
        // ============================================
        function normalizeSymbol(sym) {
            return sym ? sym.toLowerCase().replace(/\./g, '').trim() : '';
        }

        function getAssetClass(sym) {
            if (!sym) return null;
            const n = normalizeSymbol(sym);
            if (CONFIG.EXCLUDED.has(n)) return null;
            return ASSET_MAP[n] || null;
        }

        function isStablePair(sym) {
            return CONFIG.STABLE_PAIRS.has(normalizeSymbol(sym));
        }

        function getPairType(baseAsset, quoteAsset, baseSym, quoteSym) {
            if (!baseAsset || !quoteAsset) return null;

            // Check stable-stable first
            if (isStablePair(baseSym) && isStablePair(quoteSym)) {
                if (normalizeSymbol(baseSym) !== normalizeSymbol(quoteSym)) {
                    return 'stable-stable';
                }
            }

            // Same asset class = wrapped twins
            if (baseAsset === quoteAsset) {
                return (baseAsset === 'BTC' || baseAsset === 'ETH') ? 'wrapped' : null;
            }

            const sorted = [baseAsset, quoteAsset].sort().join('-');
            if (sorted === 'BTC-STABLE') return 'btc-stable';
            if (sorted === 'ETH-STABLE') return 'eth-stable';
            if (sorted === 'BTC-ETH') return 'btc-eth';

            return null;
        }

        function extractFee(name) {
            if (!name) return null;
            const pct = name.match(/(\d+\.?\d*)\s*%/);
            if (pct) {
                const f = parseFloat(pct[1]);
                if (f > 0 && f < 10) return f;
            }
            const bps = name.match(/(\d+)\s*bps/i);
            if (bps) return parseFloat(bps[1]) / 100;
            return null;
        }

        function normalizeGeckoPool(poolData, included = [], network) {
            if (!poolData || !poolData.attributes) return null;

            const attr = poolData.attributes;
            const address = attr.address;
            if (!address) return null;

            // Find base and quote tokens from included data
            const baseTokenRef = poolData.relationships?.base_token?.data;
            const quoteTokenRef = poolData.relationships?.quote_token?.data;
            const dexRef = poolData.relationships?.dex?.data;

            let baseSym = null, quoteSym = null, protocol = 'Unknown';

            if (included && included.length > 0) {
                const baseToken = included.find(i => i.type === 'token' && i.id === baseTokenRef?.id);
                const quoteToken = included.find(i => i.type === 'token' && i.id === quoteTokenRef?.id);
                const dex = included.find(i => i.type === 'dex' && i.id === dexRef?.id);

                baseSym = baseToken?.attributes?.symbol;
                quoteSym = quoteToken?.attributes?.symbol;
                protocol = dex?.attributes?.name || dexRef?.id || 'Unknown';
            }

            // Fallback: parse from pool name
            if (!baseSym || !quoteSym) {
                const name = attr.name || '';
                const parts = name.split(/[\s\/\-]+/).filter(p => p && !/^^\d/.test(p) && p !== '%');
                if (parts.length >= 2) {
                    baseSym = baseSym || parts[0];
                    quoteSym = quoteSym || parts[1];
                }
            }

            if (!baseSym || !quoteSym) return null;
            if (CONFIG.EXCLUDED.has(normalizeSymbol(baseSym)) || CONFIG.EXCLUDED.has(normalizeSymbol(quoteSym))) return null;

            const baseAsset = getAssetClass(baseSym);
            const quoteAsset = getAssetClass(quoteSym);
            if (!baseAsset && !quoteAsset) return null;

            const pairType = getPairType(baseAsset, quoteAsset, baseSym, quoteSym);
            if (!pairType) return null;

            const liquidity = parseFloat(attr.reserve_in_usd) || 0;
            const volume24h = parseFloat(attr.volume_usd?.h24) || 0;
            const fee = extractFee(attr.name) || CONFIG.DEFAULT_FEE;

            // Build pool name
            let poolName = `${baseSym} / ${quoteSym}`;
            if (fee !== CONFIG.DEFAULT_FEE) {
                poolName += ` ${fee}%`;
            }

            // Clean up protocol name
            protocol = protocol.replace(/_/g, ' ').split(' ').map(w => 
                w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
            ).join(' ');

            const uniqueId = `${network}_${address.toLowerCase()}`;

            return {
                id: uniqueId,
                name: poolName,
                baseSym,
                quoteSym,
                baseAsset,
                quoteAsset,
                pairType,
                liquidity,
                volume24h,
                volumeData: { '24h': volume24h },
                fee,
                chain: CONFIG.NETWORK_NAMES[network] || network,
                chainId: network,
                protocol,
                address,
                poolUrl: `https://www.geckoterminal.com/${network}/pools/${address}`,
                explorerUrl: CONFIG.EXPLORERS[network] ? CONFIG.EXPLORERS[network] + address : '',
                dataSource: 'geckoterminal'
            };
        }

        // ============================================
        // DATA FETCHING
        // ============================================
        async function discoverPoolsForNetwork(network, onProgress) {
            const discovered = new Map();
            let step = 0;

            log(`[GeckoTerminal] Loading pools for ${network}...`, 'gecko');

            // Step 1: Fetch top pools (multiple pages)
            for (let page = 1; page <= CONFIG.MAX_PAGES_PER_NETWORK; page++) {
                const res = await fetchTopPools(network, page);
                if (!res || !res.data || res.data.length === 0) break;

                res.data.forEach(pool => {
                    const norm = normalizeGeckoPool(pool, res.included || [], network);
                    if (norm && !discovered.has(norm.id) && !state.pools.has(norm.id)) {
                        if (norm.liquidity >= CONFIG.MIN_LIQUIDITY && norm.volume24h >= CONFIG.MIN_VOLUME_24H) {
                            discovered.set(norm.id, norm);
                        }
                    }
                });

                step++;
                if (onProgress) onProgress((step / (CONFIG.MAX_PAGES_PER_NETWORK + Object.values(CONFIG.SEARCHES).flat().length)) * 100);
            }

            // Step 2: Search for specific pair types
            const allSearches = Object.values(CONFIG.SEARCHES).flat();
            for (const query of allSearches) {
                const pools = await searchPools(query, network);
                pools.forEach(pool => {
                    const norm = normalizeGeckoPool(pool, [], network);
                    if (norm && !discovered.has(norm.id) && !state.pools.has(norm.id)) {
                        if (norm.liquidity >= CONFIG.MIN_LIQUIDITY && norm.volume24h >= CONFIG.MIN_VOLUME_24H) {
                            discovered.set(norm.id, norm);
                        }
                    }
                });

                step++;
                if (onProgress) onProgress((step / (CONFIG.MAX_PAGES_PER_NETWORK + allSearches.length)) * 100);
            }

            state.loadedNetworks.add(network);
            log(`[GeckoTerminal] Found ${discovered.size} pools on ${network}`, 'gecko');
            return discovered;
        }

        async function discoverPools(networks, onProgress) {
            const allDiscovered = new Map();
            let networksDone = 0;

            for (const network of networks) {
                if (state.loadedNetworks.has(network)) continue;

                const discovered = await discoverPoolsForNetwork(network, pct => {
                    const overall = ((networksDone + (pct / 100)) / networks.length) * 100;
                    if (onProgress) onProgress(overall);
                });

                discovered.forEach((pool, id) => allDiscovered.set(id, pool));
                networksDone++;

                if (onProgress) onProgress((networksDone / networks.length) * 100);
            }

            log(`[GeckoTerminal] Total discovered: ${allDiscovered.size} pools from ${networks.length} networks`, 'success');
            return allDiscovered;
        }

        // ============================================
        // FILTERING & SORTING
        // ============================================
        function getPoolsForSection(sectionId) {
            const sec = state.sections[sectionId];
            const pools = [];

            state.pools.forEach(pool => {
                if (pool.pairType !== sectionId) return;
                if (!sec.networks.includes(pool.chainId)) return;
                if (pool.liquidity < CONFIG.MIN_LIQUIDITY) return;
                if (pool.volume24h < CONFIG.MIN_VOLUME_24H) return;
                pools.push({ ...pool });
            });

            return pools;
        }

        function calculateMetrics(pool, timeframe) {
            const days = CONFIG.TIMEFRAMES[timeframe].days;
            const displayVol = pool.volumeData[timeframe];

            if (displayVol == null || displayVol <= 0) {
                pool.displayVolume = null;
                pool.utilization = null;
                pool.apr = null;
                pool.hasRealData = false;
                return pool;
            }

            pool.displayVolume = displayVol;
            pool.hasRealData = true;

            const dailyVolume = displayVol / days;
            pool.utilization = pool.liquidity > 0 ? dailyVolume / pool.liquidity : 0;

            if (pool.liquidity > 0) {
                const feesEarned = displayVol * (pool.fee / 100);
                const annualizedFees = (feesEarned * 365) / days;
                pool.apr = (annualizedFees / pool.liquidity) * 100;
            } else {
                pool.apr = 0;
            }

            return pool;
        }

        function sortPools(pools, field, dir) {
            return pools.sort((a, b) => {
                let av = a[field], bv = b[field];
                if (typeof av === 'string') av = av.toLowerCase();
                if (typeof bv === 'string') bv = bv.toLowerCase();
                if (av == null) av = dir === 'asc' ? Infinity : -Infinity;
                if (bv == null) bv = dir === 'asc' ? Infinity : -Infinity;
                return dir === 'asc' ? (av > bv ? 1 : -1) : (av < bv ? 1 : -1);
            });
        }

        // ============================================
        // OHLCV FETCHING
        // ============================================
        async function fetchOHLCVForSection(sectionId, timeframe) {
            if (timeframe === '24h') return;

            const sec = state.sections[sectionId];
            const pools = getPoolsForSection(sectionId);
            const days = CONFIG.TIMEFRAMES[timeframe].days;

            const poolsToFetch = pools.filter(pool => {
                const key = `${pool.id}_${timeframe}`;
                return sec.ohlcvCache[key] === undefined;
            });

            log(`[${sectionId}] Fetching ${timeframe} volume for ${poolsToFetch.length} pools...`, 'gecko');

            let fetched = 0;
            for (const pool of poolsToFetch) {
                const key = `${pool.id}_${timeframe}`;
                setSectionLoading(sectionId, true, `Fetching ${days}d volume: ${fetched + 1}/${poolsToFetch.length} pools...`);

                const result = await fetchOHLCV(pool.chainId, pool.address, days);
                sec.ohlcvCache[key] = result.volume;

                const cached = state.pools.get(pool.id);
                if (cached) {
                    cached.volumeData[timeframe] = result.volume;
                }

                fetched++;
            }

            // Update from cache
            pools.forEach(pool => {
                const key = `${pool.id}_${timeframe}`;
                if (sec.ohlcvCache[key] !== undefined) {
                    const cached = state.pools.get(pool.id);
                    if (cached) {
                        cached.volumeData[timeframe] = sec.ohlcvCache[key];
                    }
                }
            });

            log(`[${sectionId}] Completed ${timeframe} volume fetch`, 'success');
        }

        // ============================================
        // RENDERING
        // ============================================
        function getUtilClass(u) {
            if (u == null) return '';
            const p = u * 100;
            if (p >= 50) return 'utilization-excellent';
            if (p >= 20) return 'utilization-high';
            if (p >= 5) return 'utilization-moderate';
            return 'utilization-low';
        }

        function getAprClass(apr) {
            if (apr == null) return '';
            if (apr >= 50) return 'apr-excellent';
            if (apr >= 20) return 'apr-good';
            if (apr >= 5) return 'apr-moderate';
            return 'apr-low';
        }

        function getFeeClass(fee) {
            if (fee <= 0.05) return 'fee-low';
            if (fee <= 0.3) return 'fee-medium';
            return 'fee-high';
        }

        function renderPoolRow(pool, tf) {
            const liqPct = Math.min(100, Math.max(0,
                (Math.log10(Math.max(pool.liquidity, CONFIG.MIN_LIQUIDITY)) - Math.log10(CONFIG.MIN_LIQUIDITY)) /
                (Math.log10(500000000) - Math.log10(CONFIG.MIN_LIQUIDITY)) * 100
            ));

            const tfInd = tf !== '24h' ? `<span class="tf-indicator">(${tf})</span>` : '';
            const volumeDisplay = pool.displayVolume != null ? formatUsd(pool.displayVolume) : 'N/A';
            const utilDisplay = pool.utilization != null ? formatUtilization(pool.utilization) : 'N/A';
            const aprDisplay = pool.apr != null ? pool.apr.toFixed(1) + '%' : 'N/A';

            return `
                <tr>
                    <td class="col-chain">${escapeHtml(pool.chain)}</td>
                    <td class="col-protocol"><span class="protocol-badge" title="${escapeHtml(pool.protocol)}">${escapeHtml(pool.protocol)}</span></td>
                    <td class="col-pool">
                        <div class="pool-cell">
                            <a href="${escapeHtml(pool.poolUrl)}" target="_blank" class="pool-link">${colorizePoolName(pool.name)}</a>
                            <a href="${pool.explorerUrl || '#'}" target="_blank" class="explorer-link" title="View contract" ${!pool.explorerUrl ? 'style="visibility:hidden"' : ''}>📋</a>
                        </div>
                    </td>
                    <td class="col-fee"><span class="fee-badge ${getFeeClass(pool.fee)}">${pool.fee.toFixed(2)}%</span></td>
                    <td class="col-liquidity liquidity-cell">
                        <div class="liquidity-bar" style="width:${liqPct}%"></div>
                        <span class="liquidity-value">${formatUsd(pool.liquidity)}</span>
                    </td>
                    <td class="col-volume volume-cell">${volumeDisplay}${tfInd}</td>
                    <td class="col-util utilization-value ${getUtilClass(pool.utilization)}">${utilDisplay}</td>
                    <td class="col-apr apr-cell apr-value ${getAprClass(pool.apr)}">${aprDisplay}${tfInd}</td>
                </tr>
            `;
        }

        function renderSection(sectionId) {
            const sec = state.sections[sectionId];
            let pools = getPoolsForSection(sectionId)
                .map(p => calculateMetrics(p, sec.timeframe));

            if (sec.timeframe !== '24h') {
                pools = pools.filter(p => p.hasRealData);
            }

            const sorted = sortPools(pools, sec.sortField, sec.sortDir);

            const tbody = document.getElementById(`${sectionId}-tbody`);
            const noData = document.getElementById(`${sectionId}-nodata`);
            const count = document.getElementById(`${sectionId}-count`);

            if (count) count.textContent = `(${sorted.length})`;

            if (sorted.length === 0) {
                if (tbody) tbody.innerHTML = '';
                if (noData) noData.classList.remove('hidden');
            } else {
                if (tbody) tbody.innerHTML = sorted.map(p => renderPoolRow(p, sec.timeframe)).join('');
                if (noData) noData.classList.add('hidden');
            }

            updateNetworkBadge(sectionId);
        }

        function renderAllSections() {
            CONFIG.SECTIONS.forEach(s => renderSection(s.id));
        }

        function setSectionLoading(sectionId, loading, msg = 'Loading...') {
            const overlay = document.getElementById(`${sectionId}-overlay`);
            const text = overlay?.querySelector('.section-overlay-text');
            if (text) text.textContent = msg;
            overlay?.classList.toggle('active', loading);
        }

        // ============================================
        // SECTION HTML GENERATION
        // ============================================
        function generateSectionHTML(config) {
            const tfButtons = Object.keys(CONFIG.TIMEFRAMES).map(tf =>
                `<button class="tf-btn${tf === '24h' ? ' active' : ''}" data-tf="${tf}">${tf}</button>`
            ).join('');

            return `
                <div class="pair-section${config.grid ? '' : ' full-width'}" id="${config.id}-section">
                    <div class="section-header">
                        <div class="section-title">
                            ${config.title}
                            <span class="pool-count" id="${config.id}-count">(0)</span>
                        </div>
                        <div class="section-controls">
                            <div class="timeframe-toggle" data-section="${config.id}">
                                ${tfButtons}
                            </div>
                            <div class="network-selector" data-section="${config.id}">
                                <button class="network-btn" type="button">
                                    <span>Networks</span>
                                    <span class="network-badge" id="${config.id}-netbadge">3</span>
                                    <span class="network-arrow">▼</span>
                                </button>
                                <div class="network-dropdown" id="${config.id}-dropdown"></div>
                            </div>
                        </div>
                    </div>
                    <div class="section-content">
                        <div class="table-container">
                            <table class="pool-table">
                                <thead>
                                    <tr>
                                        <th class="col-chain" data-sort="chain" data-section="${config.id}">Chain</th>
                                        <th class="col-protocol" data-sort="protocol" data-section="${config.id}">Protocol</th>
                                        <th class="col-pool" data-sort="name" data-section="${config.id}">Pool</th>
                                        <th class="col-fee" data-sort="fee" data-section="${config.id}">Fee</th>
                                        <th class="col-liquidity" data-sort="liquidity" data-section="${config.id}">Liquidity</th>
                                        <th class="col-volume" data-sort="displayVolume" data-section="${config.id}">Volume</th>
                                        <th class="col-util" data-sort="utilization" data-section="${config.id}">Util %</th>
                                        <th class="col-apr" data-sort="apr" data-section="${config.id}">Est. APR</th>
                                    </tr>
                                </thead>
                                <tbody id="${config.id}-tbody"></tbody>
                            </table>
                            <div class="no-data hidden" id="${config.id}-nodata">No pools found. Select more networks or check filters.</div>
                        </div>
                    </div>
                    <div class="section-overlay" id="${config.id}-overlay">
                        <div class="spinner"></div>
                        <div class="section-overlay-text">Loading...</div>
                    </div>
                </div>
            `;
        }

        function buildSections() {
            const grid = document.getElementById('dashboard-grid');
            const wrapper = document.getElementById('stablecoin-section-wrapper');

            grid.innerHTML = '';
            wrapper.innerHTML = '';

            CONFIG.SECTIONS.forEach(s => {
                const html = generateSectionHTML(s);
                if (s.grid) {
                    grid.insertAdjacentHTML('beforeend', html);
                } else {
                    wrapper.insertAdjacentHTML('beforeend', html);
                }
            });
        }

        // ============================================
        // NETWORK DROPDOWN
        // ============================================
        function buildDropdownHTML(sectionId) {
            const sec = state.sections[sectionId];
            let html = `
                <div class="dropdown-header">
                    <span>Filter Networks</span>
                    <button type="button" class="select-loaded-btn">Select All Loaded</button>
                </div>
                <div class="dropdown-content">
            `;

            Object.entries(CONFIG.NETWORK_GROUPS).forEach(([group, nets]) => {
                html += `<div class="network-group-label">${group}</div>`;
                nets.forEach(net => {
                    const isLoaded = state.loadedNetworks.has(net.id);
                    html += `
                        <div class="network-item" data-net="${net.id}">
                            <div class="network-checkbox"></div>
                            <span class="network-name">${net.name}</span>
                            ${net.initial ? '<span class="network-tag">Initial</span>' : ''}
                            ${isLoaded ? '<span class="loaded-tag">Loaded</span>' : '<span class="not-loaded-tag">Click to load</span>'}
                        </div>
                    `;
                });
            });

            html += `
                </div>
                <div class="dropdown-footer">
                    <div class="dropdown-footer-info" id="${sectionId}-footer-info"></div>
                    <div class="dropdown-footer-buttons">
                        <button class="btn cancel-btn">Cancel</button>
                        <button class="btn btn-primary apply-btn">Apply</button>
                    </div>
                </div>
            `;

            return html;
        }

        function updateNetworkBadge(sectionId) {
            const badge = document.getElementById(`${sectionId}-netbadge`);
            const sec = state.sections[sectionId];
            if (badge) {
                badge.textContent = sec.networks.filter(n => state.loadedNetworks.has(n)).length;
            }
        }

        function updateDropdownUI(sectionId) {
            const dropdown = document.getElementById(`${sectionId}-dropdown`);
            const sec = state.sections[sectionId];
            const footerInfo = document.getElementById(`${sectionId}-footer-info`);

            let networksToLoad = 0;

            dropdown.querySelectorAll('.network-item').forEach(item => {
                const netId = item.dataset.net;
                const selected = sec.pendingNetworks.includes(netId);
                const loaded = state.loadedNetworks.has(netId);

                item.classList.toggle('selected', selected);
                item.classList.toggle('not-loaded', !loaded);
                item.querySelector('.network-checkbox').textContent = selected ? '✓' : '';

                // Update tags
                const loadedTag = item.querySelector('.loaded-tag');
                const notLoadedTag = item.querySelector('.not-loaded-tag');

                if (loaded) {
                    if (!loadedTag) {
                        const newTag = document.createElement('span');
                        newTag.className = 'loaded-tag';
                        newTag.textContent = 'Loaded';
                        item.appendChild(newTag);
                    }
                    if (notLoadedTag) notLoadedTag.remove();
                } else {
                    if (!notLoadedTag) {
                        const newTag = document.createElement('span');
                        newTag.className = 'not-loaded-tag';
                        newTag.textContent = 'Click to load';
                        item.appendChild(newTag);
                    }
                    if (loadedTag) loadedTag.remove();
                    if (selected) networksToLoad++;
                }
            });

            if (footerInfo) {
                if (networksToLoad > 0) {
                    footerInfo.innerHTML = `<span class="to-load">${networksToLoad} network(s) will be loaded</span>`;
                } else {
                    footerInfo.textContent = '';
                }
            }
        }

        function positionDropdown(btn, dropdown) {
            const rect = btn.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const dropdownWidth = 320;

            dropdown.style.top = (rect.bottom + 4) + 'px';

            if (rect.right < dropdownWidth + 20) {
                dropdown.style.left = Math.max(10, rect.left) + 'px';
                dropdown.style.right = 'auto';
            } else {
                dropdown.style.right = Math.max(10, viewportWidth - rect.right) + 'px';
                dropdown.style.left = 'auto';
            }

            requestAnimationFrame(() => {
                const dRect = dropdown.getBoundingClientRect();
                if (dRect.bottom > window.innerHeight - 20) {
                    dropdown.style.top = 'auto';
                    dropdown.style.bottom = (window.innerHeight - rect.top + 4) + 'px';
                }
            });
        }

        function closeAllDropdowns() {
            document.querySelectorAll('.network-dropdown.open').forEach(d => d.classList.remove('open'));
            document.querySelectorAll('.network-btn.open').forEach(b => b.classList.remove('open'));
        }

        function initNetworkSelectors() {
            CONFIG.SECTIONS.forEach(s => {
                const dropdown = document.getElementById(`${s.id}-dropdown`);
                if (dropdown) dropdown.innerHTML = buildDropdownHTML(s.id);
            });

            document.querySelectorAll('.network-selector').forEach(sel => {
                const sectionId = sel.dataset.section;
                const btn = sel.querySelector('.network-btn');
                const dropdown = sel.querySelector('.network-dropdown');

                btn.addEventListener('click', e => {
                    e.stopPropagation();
                    const wasOpen = dropdown.classList.contains('open');
                    closeAllDropdowns();

                    if (!wasOpen) {
                        dropdown.innerHTML = buildDropdownHTML(sectionId);
                        reattachDropdownListeners(sectionId, dropdown);
                        state.sections[sectionId].pendingNetworks = [...state.sections[sectionId].networks];
                        updateDropdownUI(sectionId);
                        dropdown.classList.add('open');
                        btn.classList.add('open');
                        positionDropdown(btn, dropdown);
                    }
                });

                dropdown.addEventListener('click', e => e.stopPropagation());
            });

            document.addEventListener('click', closeAllDropdowns);

            window.addEventListener('scroll', () => {
                document.querySelectorAll('.network-dropdown.open').forEach(dropdown => {
                    const btn = dropdown.closest('.network-selector').querySelector('.network-btn');
                    positionDropdown(btn, dropdown);
                });
            }, true);
        }

        function reattachDropdownListeners(sectionId, dropdown) {
            dropdown.querySelectorAll('.network-item').forEach(item => {
                item.addEventListener('click', () => {
                    const netId = item.dataset.net;
                    const pending = state.sections[sectionId].pendingNetworks;
                    const idx = pending.indexOf(netId);
                    if (idx > -1) {
                        pending.splice(idx, 1);
                    } else {
                        pending.push(netId);
                    }
                    updateDropdownUI(sectionId);
                });
            });

            dropdown.querySelector('.select-loaded-btn').addEventListener('click', () => {
                state.sections[sectionId].pendingNetworks = [...state.loadedNetworks];
                updateDropdownUI(sectionId);
            });

            dropdown.querySelector('.cancel-btn').addEventListener('click', () => {
                closeAllDropdowns();
            });

            dropdown.querySelector('.apply-btn').addEventListener('click', async () => {
                const sec = state.sections[sectionId];
                const networksToLoad = sec.pendingNetworks.filter(n => !state.loadedNetworks.has(n));

                closeAllDropdowns();

                if (networksToLoad.length > 0) {
                    await loadNetworksOnDemand(sectionId, networksToLoad);
                }

                sec.networks = sec.pendingNetworks.filter(n => state.loadedNetworks.has(n));
                renderSection(sectionId);
                updateHeaderStatus('', 'success');
                log(`[${sectionId}] Applied network filter: ${sec.networks.join(', ')}`, 'info');
            });
        }

        // ============================================
        // ON-DEMAND NETWORK LOADING
        // ============================================
        async function loadNetworksOnDemand(sectionId, networks) {
            if (networks.length === 0) return;

            setSectionLoading(sectionId, true, `Loading ${networks.length} network(s)...`);
            log(`[${sectionId}] Loading networks on-demand: ${networks.join(', ')}`, 'info');

            try {
                updateHeaderStatus(`Loading ${networks.join(', ')}...`, 'info', true);

                const discovered = await discoverPools(networks, pct => {
                    setSectionLoading(sectionId, true, `Loading networks: ${Math.round(pct)}%`);
                });

                discovered.forEach((pool, id) => state.pools.set(id, pool));
                updateHeaderStatus('', 'success');
                log(`[${sectionId}] Loaded ${discovered.size} pools from ${networks.length} networks`, 'success');

            } catch (err) {
                log(`[${sectionId}] Error loading networks: ${err.message}`, 'error');
                updateHeaderStatus('Error loading networks', 'error');
            } finally {
                setSectionLoading(sectionId, false);
            }
        }

        // ============================================
        // TIMEFRAME HANDLERS
        // ============================================
        function initTimeframeToggles() {
            document.querySelectorAll('.timeframe-toggle').forEach(toggle => {
                const sectionId = toggle.dataset.section;

                toggle.querySelectorAll('.tf-btn').forEach(btn => {
                    btn.addEventListener('click', async () => {
                        const tf = btn.dataset.tf;
                        const sec = state.sections[sectionId];

                        if (tf === sec.timeframe) return;

                        toggle.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        sec.timeframe = tf;

                        if (tf !== '24h') {
                            const poolCount = getPoolsForSection(sectionId).length;
                            setSectionLoading(sectionId, true, `Fetching ${CONFIG.TIMEFRAMES[tf].days}d volume for ${poolCount} pools...`);
                            await fetchOHLCVForSection(sectionId, tf);
                            setSectionLoading(sectionId, false);
                        }

                        renderSection(sectionId);
                        log(`[${sectionId}] Changed timeframe to ${tf}`, 'info');
                    });
                });
            });
        }

        // ============================================
        // SORTING
        // ============================================
        function initSorting() {
            document.querySelectorAll('th[data-sort]').forEach(th => {
                th.addEventListener('click', () => {
                    const sectionId = th.dataset.section;
                    const field = th.dataset.sort;
                    const sec = state.sections[sectionId];

                    if (sec.sortField === field) {
                        sec.sortDir = sec.sortDir === 'asc' ? 'desc' : 'asc';
                    } else {
                        sec.sortField = field;
                        sec.sortDir = 'desc';
                    }

                    document.querySelectorAll(`th[data-section="${sectionId}"]`).forEach(h => {
                        h.classList.remove('sort-asc', 'sort-desc');
                    });
                    th.classList.add(`sort-${sec.sortDir}`);

                    renderSection(sectionId);
                });
            });
        }

        // ============================================
        // MAIN OPERATIONS
        // ============================================
        async function loadInitialData() {
            if (state.isLoading) return;
            state.isLoading = true;

            const refreshBtn = document.getElementById('refresh-btn');
            refreshBtn.disabled = true;

            state.pools.clear();
            state.loadedNetworks.clear();
            state.apiCalls = 0;
            state.debugLogs = [];

            CONFIG.SECTIONS.forEach(s => {
                const sec = state.sections[s.id];
                sec.networks = [...CONFIG.INITIAL_NETWORKS];
                sec.pendingNetworks = [...CONFIG.INITIAL_NETWORKS];
                sec.timeframe = '24h';
                sec.ohlcvCache = {};
                setSectionLoading(s.id, true, 'Loading pools via GeckoTerminal...');

                const toggle = document.querySelector(`.timeframe-toggle[data-section="${s.id}"]`);
                if (toggle) {
                    toggle.querySelectorAll('.tf-btn').forEach(b => {
                        b.classList.toggle('active', b.dataset.tf === '24h');
                    });
                }
            });

            try {
                log('Loading from Ethereum, Arbitrum, Base via GeckoTerminal...', 'gecko');
                updateHeaderStatus('Loading pools...', 'info', true);

                const discovered = await discoverPools(CONFIG.INITIAL_NETWORKS, updateProgress);
                discovered.forEach((pool, id) => state.pools.set(id, pool));

                renderAllSections();
                updateHeaderStatus('', 'success');
                document.getElementById('last-updated').textContent = `Updated: ${new Date().toLocaleTimeString()}`;

                log(`Initial load complete. ${state.pools.size} pools, ${state.apiCalls} API calls`, 'success');

            } catch (err) {
                log(`Load error: ${err.message}`, 'error');
                updateHeaderStatus('Error loading data', 'error');
            } finally {
                state.isLoading = false;
                refreshBtn.disabled = false;
                updateProgress(0);
                CONFIG.SECTIONS.forEach(s => setSectionLoading(s.id, false));
            }
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            buildSections();
            initNetworkSelectors();
            initTimeframeToggles();
            initSorting();

            document.getElementById('refresh-btn').addEventListener('click', loadInitialData);

            document.getElementById('debug-toggle').addEventListener('click', () => {
                document.getElementById('debug-section').classList.toggle('hidden');
            });

            document.getElementById('clear-debug').addEventListener('click', () => {
                state.debugLogs = [];
                renderDebugLog();
            });

            loadInitialData();
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    })();
    </script>
</body>
</html>
